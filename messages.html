<!--
================================================================================
UNIMARKET - MESSAGES PAGE (messages.html)
================================================================================

PURPOSE:
Real-time messaging interface for UniMarket where users can chat with each other
about products. Displays conversation list, message history, and input for sending
new messages.

WHAT THIS PAGE DOES:
1. Shows all conversation partners (users you've messaged)
2. Displays unread message count for each conversation (numbered badges)
3. Shows message history when you click a conversation
4. Allows you to type and send new messages
5. Marks messages as read when you view them
6. Shows notification badge (red dot) when you have unread messages
7. Auto-scrolls to latest messages
8. Responsive design (hides conversation list on mobile, click back to show)

KEY FEATURES:
‚úì Real-time Chat: Instant message delivery via Socket.IO
‚úì Message History: Load past conversations from database
‚úì Unread Badges: Numbers on each conversation + red dot on icon
‚úì Read Status: Messages marked as read when viewed
‚úì User Info: Shows profile pictures, names, usernames
‚úì Timestamps: Shows when each message was sent
‚úì Responsive: Works on desktop, tablet, and mobile

HOW IT WORKS:
1. Page loads -> Check if user logged in -> Load conversations
2. For each user: Fetch messages and count unread ones
3. Display list of conversations sorted by most recent
4. User clicks conversation -> Load all messages with that user
5. User opens chat -> Backend marks messages as read
6. Notification badges disappear (no more unread)
7. User types message -> Click send -> POST /api/messages
8. Backend saves message + emits Socket.IO event if online
9. Real-time updates: Other user sees message instantly (if online)
10. If other user offline: They see message when they reconnect

TECHNICAL STACK:
- Frontend: HTML5, CSS3, JavaScript ES6+
- Real-time: Socket.IO (WebSocket) for instant delivery
- APIs: REST endpoints for persistence (POST, GET, PUT)
- Database: SQLite/PostgreSQL for message storage
- Icons: Lucide Icons (SVG)
- Styling: CSS variables for theming

FILE SECTIONS:
1. Head: Meta tags, stylesheets, libraries
2. Body: HTML structure
   - Header: Shows user profile
   - Conversation list: All your chat partners (left sidebar)
   - Chat view: Messages and input (main area)
3. Scripts:
   - Socket.IO initialization
   - Event listeners (connect, receive_message)
   - Page functions (loadConversations, selectConversation, sendMessage)
   - UI management (renderConversations, renderMessages)

IMPORTANT VARIABLES:
- currentConversationUserId: Which user's conversation is open
- currentUserId: Your user ID (logged in)
- allUsers: Cache of all user data
- conversations: List of users you're chatting with
- socket: Socket.IO connection object

WEBSOCKET CONNECTION:
- Connects to backend on port 8000
- Auto-reconnects if connection drops
- Authenticates with user ID on connect
- Listens for receive_message events

STYLING:
- Inline styles in JavaScript (for dynamic badges)
- CSS from style.css (main styling)
- Mobile-first design with media queries
- Hidden header shadow, responsive grid layout

SECURITY:
- JWT token required to access page (stored in localStorage)
- All API calls include authorization header
- Messages not sent to strangers (only visible to sender/receiver)
- Read-only operations for security
================================================================================
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Messages - UniMarket</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Socket.IO Client Library for real-time WebSocket messaging -->
    <script src="https://cdn.socket.io/4.8.0/socket.io.min.js"></script>
    <style>
        body {
            overflow: hidden;
        }

        .messages-layout {
            display: grid;
            grid-template-columns: 1fr;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .messages-layout {
                grid-template-columns: 320px 1fr;
            }
        }

        .conversations-list {
            border-right: 1px solid var(--border);
            overflow-y: auto;
            display: none;
        }

        @media (min-width: 768px) {
            .conversations-list {
                display: block;
            }
        }

        .conversation-item {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .conversation-item:hover {
            background-color: var(--secondary);
        }

        .conversation-item.active {
            background-color: var(--secondary);
        }

        .conversation-avatar {
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background-color: var(--secondary);
            overflow: hidden;
            flex-shrink: 0;
        }

        .conversation-info {
            flex: 1;
            min-width: 0;
        }

        .conversation-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .conversation-product {
            font-size: 0.875rem;
            color: var(--muted);
            margin-bottom: 0.25rem;
        }

        .conversation-last-message {
            font-size: 0.875rem;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .chat-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-shrink: 0;
            overflow: hidden;
        }

        .chat-header-back-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2rem;
            height: 2rem;
            border: none;
            background: none;
            cursor: pointer;
            color: var(--foreground);
        }

        @media (min-width: 768px) {
            .chat-header-back-btn {
                display: none;
            }
        }

        .chat-messages {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        @media (min-width: 768px) {
            .chat-messages {
                padding: 1.5rem;
                gap: 1rem;
            }
        }

        .message {
            display: flex;
            gap: 0.75rem;
            max-width: 85%;
        }

        @media (min-width: 768px) {
            .message {
                max-width: 70%;
            }
        }

        .message.me {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            background-color: var(--secondary);
            overflow: hidden;
            flex-shrink: 0;
        }

        .message-bubble {
            background-color: var(--secondary);
            padding: 0.75rem 1rem;
            border-radius: var(--radius-lg);
        }

        .message.me .message-bubble {
            background-color: var(--foreground);
            color: var(--background);
        }

        .message-time {
            font-size: 0.75rem;
            color: var(--muted);
            margin-top: 0.25rem;
        }

        .chat-input-container {
            padding: 0.75rem;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .chat-input-container {
                padding: 1rem;
            }
        }

        .chat-input {
            flex: 1;
            min-width: 0;
        }
    </style>
</head>

<body>

    <!-- Header -->
    <header class="site-header">
        <div class="container">
            <a href="/index.html" class="logo">UniMarket</a>
            <nav class="nav-links">
                <a href="/products.html" class="nav-link">Shop</a>
                <a href="/about.html" class="nav-link">About</a>
            </nav>
            <div class="search-bar">
                <i data-lucide="search" class="search-icon"></i>
                <input type="text" class="input input-pill" placeholder="Search...">
            </div>
            <div class="user-actions">
                <!-- Logged Out State -->
                <div id="logged-out-actions">
                    <a href="login.html" class="btn btn-ghost">Log In</a>
                    <a href="signup-select-university.html" class="btn btn-primary">Sign Up</a>
                </div>

                <!-- Logged In State -->
                <div id="logged-in-actions" class="hidden" style="display: flex; gap: 1rem; align-items: center;">
                    <a href="messages.html" class="btn-icon btn-ghost nav-icon" title="Messages"
                        style="color: var(--foreground);">
                        <i data-lucide="message-square"></i>
                        <span class="notification-badge hidden" id="message-badge">0</span>
                    </a>
                    <a href="saved-items.html" class="btn-icon btn-ghost nav-icon" title="Saved Items">
                        <i data-lucide="bookmark"></i>
                    </a>
                    <div class="profile-dropdown" style="position: relative;">
                        <button class="btn-icon btn-ghost nav-icon profile-dropdown-trigger" title="Profile">
                            <i data-lucide="user"></i>
                        </button>
                        <div class="profile-dropdown-menu">
                            <a href="profile.html" class="dropdown-item">View Profile</a>
                            <a href="sell.html" class="dropdown-item">Make a Listing</a>
                            <button onclick="logout()" class="dropdown-item logout-btn">Log Out</button>
                        </div>
                    </div>
                </div>
            </div>
            <button class="mobile-menu-btn"><i data-lucide="menu"></i></button>
        </div>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu">
        <div class="flex flex-col gap-4">
            <!-- Logged Out State -->
            <div id="mobile-logged-out-actions">
                <a href="products.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">Shop</a>
                <a href="about.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">About</a>
                <hr style="border-color: var(--border); margin: 0.5rem 0;">
                <a href="login.html" class="btn btn-ghost" style="text-align: center; width: 100%;">Log In</a>
                <a href="signup-select-university.html" class="btn btn-primary"
                    style="text-align: center; width: 100%;">Sign Up</a>
            </div>

            <!-- Logged In State -->
            <div id="mobile-logged-in-actions" class="hidden">
                <a href="products.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">Shop</a>
                <a href="about.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">About</a>
                <hr style="border-color: var(--border); margin: 0.5rem 0;">
                <a href="sell.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">Sell</a>
                <a href="messages.html" class="nav-link"
                    style="font-size: 1.1rem; padding: 0.5rem 0; color: var(--foreground);">Messages</a>
                <a href="saved-items.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">Saved
                    Items</a>
                <a href="profile.html" class="nav-link" style="font-size: 1.1rem; padding: 0.5rem 0;">Profile</a>
                <hr style="border-color: var(--border); margin: 0.5rem 0;">
                <button onclick="logout()" class="btn btn-outline" style="text-align: center; width: 100%;">Log
                    Out</button>
            </div>
        </div>
    </div>

    <div class="messages-layout">
        <!-- Conversations List -->
        <div class="conversations-list">
            <div style="padding: 1rem; border-bottom: 1px solid var(--border);">
                <h2 style="font-size: 1.25rem; font-weight: 700;">Messages</h2>
            </div>

            <div id="conversations-container" style="overflow-y: auto; flex: 1;">
                <!-- Conversations will be loaded here dynamically -->
                <div style="padding: 2rem 1rem; text-align: center; color: var(--muted);">
                    <p>Loading conversations...</p>
                </div>
            </div>
        </div>

        <!-- Chat Container -->
        <div class="chat-container">
            <div class="chat-header" id="chat-header">
                <button class="chat-header-back-btn" onclick="showConversationsList()">
                    <i data-lucide="chevron-left" style="width: 1.25rem; height: 1.25rem;"></i>
                </button>
                <div class="conversation-avatar" id="chat-header-avatar"
                    style="width: 2.5rem; height: 2.5rem; background: var(--secondary); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                    <i data-lucide="user" style="width: 1.25rem; height: 1.25rem; color: var(--muted);"></i>
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div id="chat-header-name" style="font-weight: 600; font-size: 0.95rem;">Select a conversation</div>
                    <div id="chat-header-product" style="font-size: 0.75rem; color: var(--muted);"></div>
                </div>
            </div>

            <div class="chat-messages" id="chat-messages">
                <div style="padding: 2rem 1rem; text-align: center; color: var(--muted);">
                    <p>Select a conversation to view messages</p>
                </div>
            </div>

            <div class="chat-input-container">
                <input type="text" id="message-input" class="input chat-input" placeholder="Type a message..." disabled>
                <button id="send-btn" class="btn btn-primary btn-icon" disabled>
                    <i data-lucide="send" style="width: 1rem;"></i>
                </button>
            </div>
        </div>
    </div>

    <script src="js/app.js"></script>
    <script>
        // =============================================================================
        // MESSAGING PAGE - REAL-TIME MESSAGE INTEGRATION
        // =============================================================================
        // This script handles the messaging interface including:
        // 1. Real-time message delivery via Socket.IO
        // 2. Loading and displaying conversations
        // 3. Handling message input and sending
        // 4. Updating notification badges

        // STATE MANAGEMENT - Variables to track the current state of the messaging interface
        let currentConversationUserId = null;  // Which user's conversation is currently open
        let currentUserId = null;              // The logged-in user's ID
        let allUsers = {};                     // Cache of all user data (for quick lookup)
        let conversations = [];                // List of users we have conversations with

        // =============================================================================
        // SOCKET.IO CONNECTION SETUP
        // =============================================================================
        // Socket.IO provides WebSocket communication for real-time messaging
        // This connects to the backend on port 8000 where the Socket.IO server runs
        // 
        // CONNECTION URL FORMAT:
        // - Frontend on port 5000 -> http://localhost:5000
        // - Backend on port 8000 -> http://localhost:8000
        // 
        // WHY DIFFERENT PORTS?
        // - Frontend: Serves static HTML/CSS/JS files (port 5000)
        // - Backend: Runs FastAPI + Socket.IO server (port 8000)
        // - They communicate via WebSocket over port 8000

        const backendUrl = window.location.protocol + '//' + window.location.hostname + ':8000';
        const socket = io(backendUrl, {
            reconnection: true,                // Auto-reconnect if connection drops
            reconnectionDelay: 1000,           // Wait 1 second before first reconnect attempt
            reconnectionDelayMax: 5000,        // Max 5 second wait between retries
            reconnectionAttempts: Infinity     // Keep trying forever (until user closes browser)
        });

        // =============================================================================
        // SOCKET.IO EVENT LISTENERS
        // =============================================================================
        // These handle real-time events from the backend server

        /**
         * CONNECT EVENT - Fires when WebSocket connection is established
         * 
         * FLOW:
         * 1. User opens messages.html
         * 2. Socket.IO client connects to backend WebSocket
         * 3. 'connect' event fires
         * 4. We send authentication with user ID
         * 5. Backend maps this socket to our user ID
         * 
         * PURPOSE: Establish connection and tell backend who we are
         */
        socket.on('connect', () => {
            console.log('Connected to messaging server');

            // Get our user ID from localStorage (set during login)
            const token = localStorage.getItem('token');
            const userId = localStorage.getItem('userId');

            // Send authenticate event to backend with our user ID
            if (userId) {
                // Backend receives this and stores: connected_users[userId] = socket_id
                socket.emit('authenticate', { userId: parseInt(userId) });
            }
        });

        /**
         * RECEIVE_MESSAGE EVENT - Fires when someone sends us a message
         * 
         * FLOW:
         * 1. User A sends message to User B
         * 2. Backend checks if User B is online (in connected_users)
         * 3. If YES: Backend emits 'receive_message' event to User B's socket
         * 4. This listener fires immediately (real-time!)
         * 5. We update the badge and reload messages if viewing that conversation
         * 
         * DATA RECEIVED:
         * {
         *   senderId: 1,
         *   content: "Hi there!",
         *   timestamp: "2025-11-23T12:00:00"
         * }
         * 
         * PURPOSE: Handle incoming messages in real-time
         */
        socket.on('receive_message', (data) => {
            console.log('Received message:', data);

            // Update the notification badge (red dot) to show we have unread messages
            if (typeof updateMessageBadge === 'function') {
                updateMessageBadge();
            }

            // If the message is from the user we're currently chatting with, reload messages
            // This makes the new message appear in the chat immediately
            if (currentConversationUserId && data.senderId == currentConversationUserId) {
                loadMessages(currentConversationUserId);
            }
        });

        // Get current user ID
        const userDataStr = localStorage.getItem('user');
        if (userDataStr) {
            currentUserId = JSON.parse(userDataStr).id;
        }

        // Get userId from URL parameter (if coming from a profile)
        function getTargetUserId() {
            const params = new URLSearchParams(window.location.search);
            return params.get('userId');
        }

        // =============================================================================
        // PAGE INITIALIZATION - Set up messaging interface when page loads
        // =============================================================================
        // This runs when the user opens messages.html
        // Loads conversations and sets up the messaging interface
        document.addEventListener('DOMContentLoaded', async () => {
            // Step 1: Check if user is logged in (has token)
            // If not logged in, redirect to login page
            if (!isLoggedIn()) {
                window.location.href = '/login.html';
                return;
            }

            // Step 2: Initialize UI
            lucide.createIcons();           // Load icons from Lucide library
            initializeLayout();             // Set up mobile/desktop layout

            // Step 3: Fetch all conversations from database
            await loadConversations();

            // Step 4: If coming from a user's profile (via link or message)
            // Auto-open the conversation with that user
            const targetUserId = getTargetUserId();  // Get user ID from URL ?userId=X
            if (targetUserId) {
                // Wait for conversations to load, then select target user's conversation
                setTimeout(() => {
                    const targetUserData = allUsers[parseInt(targetUserId)];
                    if (targetUserData) {
                        selectConversation(parseInt(targetUserId), targetUserData.full_name || targetUserData.username);
                    }
                }, 500);
            }
        });

        // =============================================================================
        // LOAD CONVERSATIONS - Fetch all conversation partners and their message counts
        // =============================================================================
        // This function:
        // 1. Gets all users from the backend
        // 2. For each user: Fetches message history
        // 3. Calculates unread count for each conversation
        // 4. Sorts by most recent message
        // 5. Renders the conversation list
        // 
        // CALLED BY: Page load, when socket receives new message
        let isLoadingConversations = false;

        async function loadConversations() {
            if (isLoadingConversations) return;
            isLoadingConversations = true;

            try {
                const token = getToken();
                if (!token) return;

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                try {
                    // Use the new optimized endpoint
                    const response = await fetch('/api/conversations', {
                        headers: { 'Authorization': `Bearer ${token}` },
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        console.error('Failed to load conversations:', response.status);
                        renderConversations([]);
                        return;
                    }

                    const conversationsWithMessages = await response.json();

                    // Update allUsers cache so we have user details for selectConversation
                    conversationsWithMessages.forEach(user => {
                        allUsers[user.id] = user;
                    });

                    renderConversations(conversationsWithMessages);
                } finally {
                    clearTimeout(timeoutId);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('Conversation loading timed out');
                    const container = document.getElementById('conversations-container');
                    if (container) {
                        container.innerHTML = '<div style="padding: 2rem 1rem; text-align: center; color: var(--muted);">Failed to load conversations. Please try again.</div>';
                    }
                } else {
                    console.error('Error loading conversations:', error);
                }
            } finally {
                isLoadingConversations = false;
            }
        }

        // Render conversations list
        function renderConversations(convos) {
            const container = document.getElementById('conversations-container');

            if (convos.length === 0) {
                container.innerHTML = '<div style="padding: 2rem 1rem; text-align: center; color: var(--muted);">No conversations yet</div>';
                return;
            }

            container.innerHTML = convos.map(user => {
                // Escape single quotes in username to prevent onclick string injection
                const escapedName = (user.fullName || user.username).replace(/'/g, "\\'");
                return `
                <div class="conversation-item" style="position: relative;" data-user-id="${user.id}" data-user-name="${escapedName}">
                    <a href="profile.html?userId=${user.id}" class="conversation-avatar" style="width: 3rem; height: 3rem; background: var(--secondary); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; text-decoration: none; flex-shrink: 0; overflow: visible; position: relative;">
                        ${user.profileImage ? `<img src="${getImageUrl(user.profileImage)}" alt="${user.username}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%; display: block;">` : `<i data-lucide="user" style="width: 1.5rem; height: 1.5rem;"></i>`}
                        ${user.unreadCount > 0 ? `<div style="position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border-radius: 50%; width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: bold; z-index: 10; border: 2px solid white;">${user.unreadCount}</div>` : ''}
                    </a>
                    <div class="conversation-info" onclick="selectConversation(${user.id}, '${escapedName}')">
                        <div class="conversation-name">${user.fullName || user.username}</div>
                        <div class="conversation-product" style="font-size: 0.8rem;">@${user.username}</div>
                        <div class="conversation-last-message">${user.lastMessage?.substring(0, 50) || 'No messages'}</div>
                    </div>
                </div>
            `;
            }).join('');

            lucide.createIcons();
        }

        // =============================================================================
        // SELECT CONVERSATION - Open a chat with a specific user
        // =============================================================================
        // This function handles everything when user clicks on a conversation:
        // 1. Updates the chat header with user's info
        // 2. Loads messages from the database
        // 3. Marks unread messages as read
        // 4. Updates notification badges
        // 5. Updates UI to show which conversation is active
        // 
        // CALLED BY: Click on conversation item, Socket.IO receive_message, page init
        // 
        // EXAMPLE:
        // selectConversation(5, "John Doe")
        // -> Opens conversation with User 5
        // -> Shows their name in header
        // -> Loads all messages between me and User 5
        // -> Marks them as read
        // -> Badge disappears
        async function selectConversation(userId, userName) {
            // DEBUG: Log when conversation is selected
            console.log('üìç selectConversation called with userId:', userId, 'userName:', userName);

            // Step 1: Save which conversation is open
            currentConversationUserId = userId;

            // Step 2: Update chat header with user's information
            const user = allUsers[userId] || { fullName: userName };
            document.getElementById('chat-header-name').textContent = user.fullName || userName;
            document.getElementById('chat-header-product').textContent = `@${user.username || 'user'}`;

            // Step 3: Set user's profile image in header (if they have one)
            if (user.profileImage) {
                document.getElementById('chat-header-avatar').innerHTML = `<img src="${getImageUrl(user.profileImage)}" alt="${userName}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
            }

            // Step 4: Make header clickable to navigate to user's profile
            const chatHeader = document.getElementById('chat-header');
            if (chatHeader) {
                chatHeader.onclick = null;  // Remove old onclick handler
                // Add new onclick to navigate to profile (but not if clicking back button)
                chatHeader.addEventListener('click', (e) => {
                    if (e.target.closest('.chat-header-back-btn')) {
                        return;  // Don't navigate if clicking back button
                    }
                    window.location.href = `profile.html?userId=${userId}`;
                });
            }

            // Step 5: Enable message input (was disabled when no conversation selected)
            document.getElementById('message-input').disabled = false;
            document.getElementById('send-btn').disabled = false;

            // Step 6: Load all messages between me and this user from database
            await loadMessages(userId);

            // Step 7: Mark messages as read (removes notification badge)
            try {
                const token = localStorage.getItem('token');
                // Call mark-read endpoint to update database
                const response = await fetch(`/api/messages/${userId}/mark-read`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    console.log('‚úÖ Messages marked as read successfully');
                    // Step 7a: Update local data - set unread count to 0
                    if (allUsers[userId]) {
                        allUsers[userId].unreadCount = 0;
                    }

                    // Step 7b: Remove badge from conversation list
                    const conversationItems = document.querySelectorAll('.conversation-item');
                    conversationItems.forEach((item, index) => {
                        const badge = item.querySelector('div[style*="background: #ef4444"]');
                        if (badge) {
                            badge.remove();  // Remove red number badge
                        }
                    });

                    // Step 7c: Update navbar message badge (red dot)
                    if (window.updateMessageBadge) {
                        window.updateMessageBadge();
                    }
                } else {
                    // API returned error status code
                    const errorData = await response.text();
                    console.error(`Failed to mark messages as read. Status: ${response.status}`, errorData);
                }
            } catch (err) {
                console.error('Error marking messages as read:', err);
            }

            // Step 8: On mobile, show chat area and hide conversation list
            if (window.innerWidth < 768) {
                showChat();
            }

            // Step 9: Update UI to show which conversation is active
            // Remove active status from all conversations
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });

            // Add active status to this conversation
            const conversationItems = document.querySelectorAll('.conversation-item');
            conversationItems.forEach((item, index) => {
                if (item.onclick && item.onclick.toString().includes(userId)) {
                    item.classList.add('active');  // Highlight active conversation
                }
            });
        }

        // =============================================================================
        // FORMAT MESSAGE TIME - Convert timestamp to readable format
        // =============================================================================
        // Converts ISO timestamps to human-readable time format
        // Examples:
        // - 59 seconds ago -> "just now"
        // - 5 minutes ago -> "12:34 PM"
        // 
        // RETURNS: Formatted time string or "unknown time" if error
        function formatMessageTime(dateStr) {
            try {
                const date = new Date(dateStr);

                // Get current time in UTC for comparison
                const now = new Date();
                const offsetMs = now.getTimezoneOffset() * 60 * 1000;
                const nowUTC = new Date(now.getTime() + offsetMs);

                // Calculate difference in milliseconds
                const diff = nowUTC.getTime() - date.getTime();

                // If less than 1 minute old, show "just now"
                if (diff < 60000) return 'just now';

                // Otherwise show time of day (e.g., "2:34 PM")
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } catch (e) {
                return 'unknown time';
            }
        }

        // =============================================================================
        // LOAD MESSAGES - Fetch all messages with a specific user from database
        // =============================================================================
        // This function:
        // 1. Calls GET /api/messages/{userId} to fetch messages from database
        // 2. Messages are returned in chronological order (oldest first)
        // 3. Includes read status for each message (is_read = 0 or 1)
        // 4. Passes messages to renderMessages() to display
        // 
        // NOTE: This does NOT mark messages as read
        // Read-marking is done separately in selectConversation()
        // 
        // PARAMETERS:
        // - userId: The other user in the conversation
        // 
        // CALLED BY: selectConversation(), Socket.IO receive_message event
        async function loadMessages(userId) {
            try {
                const token = getToken();

                // Fetch messages from backend API
                // GET /api/messages/5 -> All messages between me and user 5
                const response = await fetch(`/api/messages/${userId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) {
                    console.error('Failed to load messages');
                    return;
                }

                // Parse response and display messages
                const messages = await response.json();
                renderMessages(messages);
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        }

        // =============================================================================
        // RENDER MESSAGES - Display messages in the chat area
        // =============================================================================
        // This function takes an array of messages and renders them as HTML
        // Features:
        // 1. Shows messages from both sender and receiver
        // 2. Messages from me appear on the right (gray background)
        // 3. Messages from them appear on the left (with avatar)
        // 4. Unread messages have light gray background + red dot indicator
        // 5. Shows timestamp for each message
        // 6. Shows avatar for received messages (not for sent)
        // 7. Auto-scrolls to bottom after rendering
        // 
        // PARAMETERS:
        // - messages: Array of message objects from GET /api/messages
        // 
        // CALLED BY: loadMessages()
        function renderMessages(messages) {
            const container = document.getElementById('chat-messages');

            // If no messages, show placeholder
            if (messages.length === 0) {
                container.innerHTML = '<div style="padding: 2rem 1rem; text-align: center; color: var(--muted);">No messages yet. Start a conversation!</div>';
                return;
            }

            // Render each message
            container.innerHTML = messages.map(msg => {
                // Determine who sent the message
                const isMe = msg.senderId === currentUserId;

                // Format the timestamp
                const time = formatMessageTime(msg.createdAt);

                // Get sender's profile info
                const sender = allUsers[msg.senderId] || {};

                // Only show avatar for received messages (not for my messages)
                const hasProfilePic = sender.profileImage && !isMe;

                // Check if message is unread (to show red indicator)
                const isUnread = !isMe && msg.isRead === 0;

                // Build message HTML
                return `
                    <div class="message ${isMe ? 'me' : ''}" style="${isUnread ? 'background-color: rgba(0, 0, 0, 0.03); padding: 0.5rem; border-radius: 0.5rem; margin: -0.5rem -0.5rem 0 -0.5rem;' : ''}">
                        <div style="display: flex; align-items: flex-start; gap: 0.5rem;">
                            <!-- Sender's avatar (only for received messages) -->
                            <div class="message-avatar" style="width: 2rem; height: 2rem; background: var(--secondary); border-radius: 50%; display: flex; align-items: center; justify-content: center; overflow: hidden; flex-shrink: 0;">
                                ${hasProfilePic ? `<img src="${getImageUrl(sender.profileImage)}" alt="${sender.username}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%; display: block;">` : `<i data-lucide="user" style="width: 1rem; height: 1rem;"></i>`}
                            </div>
                            <div>
                                <!-- Message text in bubble -->
                                <div class="message-bubble">${msg.content}</div>
                                <!-- Timestamp below message -->
                                <div class="message-time">${time}</div>
                            </div>
                            <!-- Red dot for unread messages (visual indicator) -->
                            ${isUnread ? `<div style="width: 0.5rem; height: 0.5rem; background: #ef4444; border-radius: 50%; margin-top: 0.5rem; flex-shrink: 0;"></div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Load Lucide icons
            lucide.createIcons();

            // Auto-scroll to bottom to show latest messages
            // Use setTimeout to wait for DOM to fully render
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 0);
        }

        // =============================================================================
        // SEND MESSAGE - Send a message to the current conversation partner
        // =============================================================================
        // This function:
        // 1. Gets message text from input box
        // 2. Validates message is not empty and conversation selected
        // 3. Calls POST /api/messages to save to database
        // 4. Backend also emits Socket.IO event for real-time delivery
        // 5. Clears input and refreshes message display
        // 
        // HYBRID APPROACH:
        // - REST API: Saves to database (persistence)
        // - Socket.IO: Delivers in real-time if recipient is online
        // 
        // CALLED BY: Send button click, Enter key press
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const content = input.value.trim();  // Get message text and trim whitespace

            if (!content || !currentConversationUserId) return;

            try {
                const token = getToken();
                console.log('Sending message - Token exists:', !!token, 'Conversation user:', currentConversationUserId, 'Content:', content.substring(0, 20));

                if (!token) {
                    console.error('ERROR: No token found! User must log in.');
                    alert('‚ùå You are not logged in. Please log in again.');
                    window.location.href = '/login.html';
                    return;
                }

                const response = await fetch('/api/messages', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        receiverId: currentConversationUserId,
                        content: content
                    })
                });

                console.log('Message response status:', response.status);

                if (response.ok) {
                    input.value = '';
                    console.log('‚úÖ Message sent successfully');
                    await loadMessages(currentConversationUserId);

                    // Also emit via Socket.IO for real-time
                    socket.emit('send_message', {
                        senderId: currentUserId,
                        receiverId: currentConversationUserId,
                        content: content
                    });
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('‚ùå Message send failed:', response.status, errorData);
                    alert(`‚ùå Failed to send message: ${response.status}`);
                }
            } catch (error) {
                console.error('Error sending message:', error);
                alert('‚ùå Error: ' + error.message);
            }
        }

        // Event listeners
        document.getElementById('send-btn').addEventListener('click', sendMessage);
        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        function showConversationsList() {
            document.querySelector('.conversations-list').style.display = 'block';
            document.querySelector('.chat-container').style.display = 'none';
        }

        function showChat() {
            document.querySelector('.conversations-list').style.display = 'none';
            document.querySelector('.chat-container').style.display = 'flex';
        }

        function initializeLayout() {
            if (window.innerWidth < 768) {
                document.querySelector('.conversations-list').style.display = 'block';
                document.querySelector('.chat-container').style.display = 'none';
            }
        }

        window.addEventListener('load', initializeLayout);
        window.addEventListener('resize', initializeLayout);
    </script>
</body>

</html>