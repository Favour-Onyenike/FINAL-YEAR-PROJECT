================================================================================
UNIMARKET - PEER-TO-PEER CAMPUS MARKETPLACE
THESIS CHAPTER 3: SYSTEM REQUIREMENTS, METHODOLOGY & IMPLEMENTATION
================================================================================

STUDENT PROJECT: Final Year Thesis
UNIVERSITY: Baze University
TECHNOLOGY: Python (FastAPI) + JavaScript (HTML5/CSS3)
DATABASE: SQLite (Development) / PostgreSQL (Production-ready)
DEPLOYMENT: Cloud Platform (Linux Server)

================================================================================
1. PROJECT OVERVIEW & BUSINESS CONTEXT
================================================================================

PROJECT VISION:
UniMarket is an exclusive peer-to-peer campus marketplace designed specifically
for Baze University students to buy, sell, and trade goods safely within their
university community. The platform creates a secure, moderated space where only
authenticated university students (verified by @bazeuniversity.edu.ng email)
can participate in commerce.

BUSINESS REQUIREMENTS (BR):
BR1 - University-Gated Access
      Location: backend/main.py (lines 163-170) - Email domain validation
      Location: backend/auth.py - University domain enforcement
      Requirement: Only users with @bazeuniversity.edu.ng email can register
      Implementation: Checks email domain against university domain in database

BR2 - Local Currency (Nigerian Naira - ₦)
      Location: css/style.css - Currency display formatting
      Location: All product pages show prices in ₦ (Unicode character)
      Requirement: All prices displayed and stored in Nigerian Naira
      Implementation: Frontend displays ₦ symbol; backend stores numeric values

BR3 - Peer-to-Peer Trust System
      Location: backend/models.py - User, Product, SavedItem tables
      Requirement: Enable users to browse seller profiles, ratings (future)
      Implementation: Profile system with user information display

BR4 - Safe Commerce Environment
      Location: backend/auth.py - Password security (bcrypt)
      Location: backend/main.py - JWT authentication
      Requirement: Secure authentication prevents unauthorized access
      Implementation: bcrypt hashing + JWT tokens (7-day expiry)

================================================================================
2. FUNCTIONAL REQUIREMENTS (FR)
================================================================================

AUTHENTICATION & USER MANAGEMENT
================================

FR1 - User Registration
      REQUIREMENT: New users create account with university email and password
      LOCATION: backend/main.py (lines 116-188) - /api/auth/register endpoint
      LOCATION: frontend/signup.html, signup.html
      PARAMETERS:
      - fullName (string, 2-255 chars): User's real name
      - username (string, 3-100 chars, unique): Login username
      - email (string, must match @bazeuniversity.edu.ng domain): Email
      - password (string, 6-72 chars): User password
      - universityId (integer): University ID (only Baze = 1)
      
      VALIDATION RULES:
      1. Username must not already exist (database check)
      2. Email must not already exist (database check)
      3. Email must end with @bazeuniversity.edu.ng (domain check)
      4. Password must be 6-72 characters (bcrypt limit)
      5. University must exist in database
      
      PASSWORD REQUIREMENTS (FR1.1):
      - Minimum 6 characters
      - At least 1 uppercase letter (A-Z)
      - At least 1 number (0-9)
      - Regex validation: /^(?=.*[A-Z])(?=.*\d).{6,}$/
      
      LOCATION: frontend/js/app.js (password validation function)
      LOCATION: frontend/signup.html (form validation)
      
      RESPONSE:
      - Success: {"message": "User registered successfully."}
      - Status: 201 Created
      - Error: 409 Conflict (username/email exists)
      - Error: 400 Bad Request (invalid data)

FR1.2 - Auto-Login After Signup
       REQUIREMENT: After successful signup, user auto-logs in
       LOCATION: frontend/signup.html (lines ~150-160)
       BEHAVIOR:
       1. After signup succeeds, backend returns JWT token
       2. Frontend automatically calls login endpoint
       3. Token stored in localStorage
       4. User redirected to profile page
       IMPLEMENTATION:
       - Frontend receives token from registration response
       - Automatically logs in with received credentials
       - Redirects to profile.html with user data in localStorage

FR2 - User Login
      REQUIREMENT: Existing users log in with email and password
      LOCATION: backend/main.py (lines 190-246) - /api/auth/login endpoint
      LOCATION: frontend/login.html
      
      PARAMETERS:
      - email (string): User's email
      - password (string): User's password
      
      VALIDATION RULES:
      1. Email must exist in database
      2. Password must match hashed password (bcrypt verification)
      3. User's university must be active
      
      RETURNS:
      {
          "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
          "user": {
              "id": 1,
              "fullName": "John Doe",
              "email": "john@bazeuniversity.edu.ng",
              "username": "johndoe",
              "bio": "Optional bio",
              "profileImage": "/uploads/products/avatar.jpg",
              "phone": "0801234567"
          }
      }
      
      SECURITY DETAILS (FR2.1):
      - Token expiry: 7 days (604,800 seconds)
      - Algorithm: HS256 (HMAC-SHA256)
      - Stored in: localStorage as 'token' key
      - Sent in: Authorization: Bearer <token> header

FR3 - Password Security & Hashing
      REQUIREMENT: Passwords never stored in plain text
      LOCATION: backend/auth.py (lines 85-117) - get_password_hash()
      LOCATION: backend/auth.py (lines 55-83) - verify_password()
      
      HASHING ALGORITHM: bcrypt
      ROUNDS: 12 (default from bcrypt.gensalt())
      PROCESS:
      1. Generate random salt (unique per password)
      2. Hash password + salt using bcrypt
      3. Store hash in database
      4. For verification: bcrypt compares plain password to stored hash
      
      WHY BCRYPT?
      - Intentionally slow (prevents brute force attacks)
      - Includes salt (prevents rainbow table attacks)
      - Adaptive (rounds can be increased over time)
      
      LOCATION: All user registration & password verification uses this

FR4 - JWT Token Authentication
      REQUIREMENT: API endpoints verify JWT token before allowing access
      LOCATION: backend/auth.py (lines 156-200) - get_current_user()
      LOCATION: backend/main.py - All protected endpoints use Depends(get_current_user)
      
      PROCESS:
      1. Client sends: Authorization: Bearer <token>
      2. get_current_user extracts token from header
      3. Verifies signature with SECRET_KEY
      4. Checks expiry time
      5. Queries database for user by userId in token
      6. Returns User object or raises 401 Unauthorized
      
      PROTECTED ENDPOINTS (require valid token):
      - POST /api/products (create listing)
      - PUT /api/products/{id} (update product)
      - DELETE /api/products/{id} (delete product)
      - POST /api/saved-items/toggle (bookmark product)
      - GET /api/users/{id} (get user profile)
      - PUT /api/users/{id} (update profile)
      - POST /api/upload (upload image)
      
      TOKEN FORMAT: JWT with 3 parts
      - Header: {"alg": "HS256", "typ": "JWT"}
      - Payload: {"userId": 1, "exp": 1700000000}
      - Signature: HMAC-SHA256 signed with SECRET_KEY
      
      EXPIRY: 7 days (tokens expire after 1 week)
      LOCATION: backend/auth.py (line 45): ACCESS_TOKEN_EXPIRE_MINUTES

FR5 - Email Verification (University Domain)
      REQUIREMENT: Only university emails allowed (@bazeuniversity.edu.ng)
      LOCATION: backend/main.py (lines 163-170)
      VALIDATION: email.endswith(f"@{university.domain}")
      
      BEHAVIOR:
      - During registration, email domain is checked
      - Domain must match university's domain from database
      - Currently only Baze University (ID=1) is open for registration
      - Other universities show "Coming Soon" message


PRODUCT MANAGEMENT & LISTING
=============================

FR6 - Create Product Listing (Sell an Item)
      REQUIREMENT: Users can list products for sale
      LOCATION: backend/main.py (lines 325-370) - POST /api/products
      LOCATION: frontend/sell.html
      
      PARAMETERS:
      {
          "name": "Calculus Textbook",
          "description": "Clean copy, no markings",
          "price": 3500.00,
          "categoryId": 2,
          "condition": "Like New",
          "size": "M",
          "color": "Blue",
          "images": [
              "/uploads/products/uuid1.jpg",
              "/uploads/products/uuid2.jpg",
              "/uploads/products/uuid3.jpg"
          ]
      }
      
      VALIDATION RULES (FR6.1):
      1. User must be authenticated (JWT token required)
      2. Product name: 1-255 characters
      3. Description: 1-5000 characters (product details)
      4. Price: 0-10,000,000 (numeric, no negative)
      5. Category must exist in database
      6. Condition must be: New, Like New, Good, or Fair
      7. Images: MUST be 3-5 images (mandatory minimum/maximum)
      8. Each image must be uploaded via /api/upload first
      
      IMAGE VALIDATION (FR6.2):
      - Minimum images: 3
      - Maximum images: 5
      - File types: JPEG, PNG, GIF, WebP, etc.
      - Max file size: Unlimited (implementation allows any size)
      - Storage: Backend saves to backend/uploads/products/
      - Returns: URL format /uploads/products/{uuid}.{ext}
      
      LOCATION: backend/main.py (lines 721-765) - POST /api/upload
      LOCATION: frontend/sell.html (image upload & validation)
      
      RESPONSE:
      {
          "id": 42,
          "name": "Calculus Textbook",
          "price": 3500,
          "description": "...",
          "condition": "Like New",
          "status": "available",
          "createdAt": "2025-11-22T10:30:00",
          "images": [
              {
                  "id": 101,
                  "imageUrl": "/uploads/products/abc123def.jpg",
                  "isPrimary": 1
              }
          ],
          "seller": {
              "id": 1,
              "fullName": "John Doe",
              "username": "johndoe",
              "profileImage": "/uploads/products/avatar.jpg"
          },
          "category": {
              "id": 2,
              "name": "Textbooks"
          }
      }
      
      DATABASE: Stored in products table + product_images table
      LOCATION: backend/models.py (lines 183-264)

FR7 - Browse & Search Products
      REQUIREMENT: Users can search and filter products
      LOCATION: backend/main.py (lines 372-430) - GET /api/products
      LOCATION: frontend/products.html
      
      QUERY PARAMETERS:
      - search (string): Search product names & descriptions (optional)
      - category (string): Filter by category (optional)
      - priceMin (integer): Minimum price filter (optional)
      - priceMax (integer): Maximum price filter (optional)
      - condition (string): Filter by condition (optional)
      - skip (integer): Pagination offset (default 0)
      - limit (integer): Items per page (default 20, max 100)
      
      SEARCH BEHAVIOR (FR7.1):
      - Searches product names (case-insensitive)
      - Searches product descriptions
      - Searches by multiple keywords (OR logic)
      - Location: backend/main.py (lines 390-410)
      
      FILTERING BEHAVIOR (FR7.2):
      - Filters by category ID
      - Filters by price range
      - Filters by product condition
      - All filters combinable
      - Location: backend/main.py (lines 412-428)
      
      SORTING (FR7.3):
      - Default: By creation date (newest first)
      - Can extend with: price sort, popularity sort (future)
      
      RETURNS: Array of product objects with seller info
      STATUS: 200 OK (even if no results found)
      PAGINATION: skip/limit for infinite scroll or pagination

FR8 - View Product Details
      REQUIREMENT: Users can view full product info & seller profile
      LOCATION: backend/main.py (lines 432-460) - GET /api/products/{id}
      LOCATION: frontend/product-detail.html
      
      RETURNS: Full product with all related data
      - Product info (name, description, price, condition, color, size)
      - All images with primary indicator
      - Seller profile (name, username, profile picture)
      - Seller stats (number of listings, sales count)
      - Category info
      - Timestamps (created, updated)
      
      SECURITY: Product must have status="available" (soft delete)
      ERROR: 404 Not Found if product doesn't exist or is deleted

FR9 - Update Product Listing
      REQUIREMENT: Sellers can edit their own products
      LOCATION: backend/main.py (lines 462-540) - PUT /api/products/{id}
      
      AUTHORIZATION: Only product seller can update
      - Check: current_user.id == product.seller_id
      - Error: 403 Forbidden if not owner
      
      UPDATABLE FIELDS:
      - name, description, price
      - condition, size, color
      - images (replace old images with new ones)
      
      PROCESS:
      1. User must be authenticated
      2. User must own the product
      3. Product must exist and not be deleted
      4. Update database fields
      5. Update images if provided
      6. Update timestamp (updated_at)
      
      RESPONSE: Updated product object

FR10 - Delete Product Listing (Soft Delete)
       REQUIREMENT: Sellers can remove their listings
       LOCATION: backend/main.py (lines 542-570) - DELETE /api/products/{id}
       
       SOFT DELETE: Product not permanently deleted
       - status changed from "available" to "deleted"
       - Can be restored later (future feature)
       - Soft delete preserves history for analytics
       
       AUTHORIZATION: Only product seller can delete
       - Check: current_user.id == product.seller_id
       - Error: 403 Forbidden if not owner
       
       RESPONSE: {"message": "Product deleted successfully."}
       STATUS: 200 OK


SAVED ITEMS & WISHLIST
======================

FR11 - Save/Bookmark Products
       REQUIREMENT: Users can save products to wishlist
       LOCATION: backend/main.py (lines 572-610) - POST /api/saved-items/toggle
       LOCATION: frontend/product-detail.html (bookmark button)
       
       BEHAVIOR: Toggle save (add if not saved, remove if saved)
       
       REQUEST:
       {
           "productId": 42
       }
       
       AUTHORIZATION: User must be authenticated
       
       RESPONSE:
       {
           "isSaved": true,
           "message": "Product saved."
       }
       
       DATABASE: Stored in saved_items table
       LOCATION: backend/models.py (lines 310-342)
       
       RELATIONSHIPS:
       - One user has many saved_items
       - One product can be saved by many users
       - Junction table (many-to-many relationship)

FR12 - View Saved Items
       REQUIREMENT: Users can view their bookmarked products
       LOCATION: backend/main.py (lines 612-640) - GET /api/saved-items
       LOCATION: frontend/saved-items.html
       
       AUTHORIZATION: User must be authenticated
       - Only returns current user's saved items
       - Returns empty array if nothing saved
       
       RETURNS: Array of saved product objects with all details
       
       SECURITY: Only account owner can view their saved items
       - Access control: saved-items.html checks localStorage for token
       - Redirects to login if not authenticated


USER PROFILE & ACCOUNT MANAGEMENT
==================================

FR13 - User Profile Page
       REQUIREMENT: Users can view profiles (own or others)
       LOCATION: backend/main.py (lines 642-670) - GET /api/users/{id}
       LOCATION: frontend/profile.html
       
       INFORMATION DISPLAYED:
       - Profile picture (or placeholder if not uploaded)
       - Full name and username
       - Bio (or "No bio yet" if empty)
       - Stats: Listings count, Sales count
       - Seller's products (My Listings tab)
       
       AUTHORIZATION:
       - Any user can view any profile
       - Only account owner sees "Edit Profile" button (FR13.1)
       - Only account owner sees "Saved Items" tab
       - Only account owner sees "New Listing" button
       
       QUERY PARAMETER:
       - userId (optional): View other user's profile
       - If not provided: View current logged-in user's profile
       
       RESPONSE:
       {
           "id": 1,
           "fullName": "John Doe",
           "username": "johndoe",
           "email": "john@bazeuniversity.edu.ng",
           "bio": "Love reading and gaming",
           "profileImage": "/uploads/products/avatar.jpg",
           "phone": "0801234567",
           "listings_count": 5,
           "sales_count": 3,
           "created_at": "2025-11-01T10:30:00"
       }

FR13.1 - Edit Profile (Owner-Only)
        REQUIREMENT: Users can edit their own profile
        LOCATION: backend/main.py (lines 672-720) - PUT /api/users/{id}
        LOCATION: frontend/edit-profile.html
        
        AUTHORIZATION: Only account owner can edit
        - Check: current_user.id == user_id
        - Error: 403 Forbidden if not owner
        
        EDITABLE FIELDS:
        - fullName (2-255 chars)
        - bio (optional, max 1000 chars)
        - profileImage (avatar URL from upload)
        - phone (optional, max 20 chars)
        
        IMMUTABLE FIELDS:
        - username (cannot be changed)
        - email (cannot be changed)
        - university (cannot be changed)
        
        REQUEST:
        {
            "fullName": "John Doe Updated",
            "bio": "I love studying",
            "avatarUrl": "/uploads/products/avatar.jpg",
            "phone": "0801234567"
        }
        
        RESPONSE: Updated user object
        STATUS: 200 OK

FR14 - Profile Picture Upload
       REQUIREMENT: Users can upload custom profile picture
       LOCATION: backend/main.py (lines 721-765) - POST /api/upload
       LOCATION: frontend/edit-profile.html
       
       BEHAVIOR:
       1. No default image - placeholder until user uploads
       2. Click camera icon to select image
       3. See instant preview
       4. Image auto-uploads to backend
       5. Frontend saves URL in localStorage
       6. When profile saved, avatar URL sent to backend
       
       FILE VALIDATION (FR14.1):
       - Must be image file (MIME type: image/*)
       - Supported: JPEG, PNG, GIF, WebP, SVG, etc.
       - File size: No limit (should add in production)
       - Resolution: No limit (should optimize in production)
       
       STORAGE:
       - Location: backend/uploads/products/{uuid}.{ext}
       - Filename: Random UUID + original extension
       - No overwrites (unique names prevent collisions)
       
       RESPONSE:
       {
           "imageUrl": "/uploads/products/3fa85f64-5717-4562-b3fc-2c963f66afa6.jpg"
       }
       
       SECURITY: Images served from /uploads path (static files)


NAVIGATION & UI STATE
=====================

FR15 - Dynamic Navbar Based on Login Status
       REQUIREMENT: Navbar shows different options based on authentication
       LOCATION: frontend/js/app.js (lines 181-200) - updateNavbarAuthState()
       LOCATION: frontend/index.html, products.html
       
       LOGGED OUT STATE:
       - Shows "Log In" button
       - Shows "Sign Up" button
       - No other icons visible
       
       LOGGED IN STATE:
       - Hides Login/SignUp buttons
       - Shows 4 icons instead:
         * Bell icon (Notifications - placeholder for future)
         * Message square icon (links to messages.html)
         * Bookmark icon (links to saved-items.html)
         * User icon (links to profile.html)
       
       IMPLEMENTATION:
       - JavaScript checks for JWT token in localStorage
       - If token exists: Toggle visibility of logged-in elements
       - If no token: Show login/signup buttons
       - Updates on page load
       - Updates when token is set/removed
       
       APPLIES TO: All pages with .user-actions element

FR16 - Logout Functionality
       REQUIREMENT: Users can log out and clear session
       LOCATION: backend/auth.py (logout function not in backend - frontend only)
       LOCATION: frontend/js/app.js (lines 244-250) - logout()
       
       PROCESS:
       1. Remove JWT token from localStorage
       2. Remove user data from localStorage
       3. Redirect to home page (/)
       4. Navbar updates to show Login/SignUp buttons
       
       SECURITY: Token cannot be revoked server-side (stateless auth)
       - Client-side removal is sufficient for logout
       - Token expires after 7 days anyway


CATEGORIES & ORGANIZATION
==========================

FR17 - Product Categories
       REQUIREMENT: Products organized into categories
       LOCATION: backend/models.py (lines 156-178) - Category table
       LOCATION: backend/main.py (lines 766-774) - GET /api/categories
       
       CATEGORIES:
       - Textbooks
       - Electronics
       - Clothing
       - Furniture
       - Other
       
       USAGE: Filter products by category, organize listings
       
       DATABASE:
       - Stored in categories table
       - One category has many products
       - Products filtered by category_id


REAL-TIME MESSAGING & COMMUNICATION
====================================

FR18 - Real-Time Messaging with Socket.IO
         REQUIREMENT: Users can send and receive messages in real-time
         TECHNOLOGY: Socket.IO (WebSocket) for real-time communication
         LOCATION: backend/main.py (lines 42-79 for setup, 895-1040 for handlers)
         
         OVERVIEW:
         Socket.IO enables real-time, bidirectional communication between 
         browser and server using WebSockets. In UniMarket, it powers 
         instant message delivery when both users are online.
         
         ARCHITECTURE:
         - Frontend: JavaScript Socket.IO client library (CDN)
         - Backend: Python Socket.IO AsyncServer (ASGI mode)
         - Transport: WebSocket + HTTP fallback
         - Database: Messages persisted to SQLite/PostgreSQL
         
         DEPENDENCIES INSTALLED:
         - python-socketio==5.14.3
         - python-engineio==4.12.3
         - bidict==0.23.1
         - simple-websocket==1.1.0
         - wsproto==1.3.2
         
         LOCATION: backend/main.py (lines 70-79)
         
         SOCKET.IO INITIALIZATION:
         
         sio = socketio.AsyncServer(
             async_mode='asgi',              # ASGI mode for FastAPI
             cors_allowed_origins=['*'],     # Allow all origins (dev)
             logger=False,                   # Disable logging
             engineio_logger=False
         )
         
         app_with_sio = ASGIApp(sio, app)    # Combine FastAPI + Socket.IO
         
         START COMMAND: uvicorn backend.main:app_with_sio --host 0.0.0.0 --port 8000

FR18.1 - Message Database Schema
        REQUIREMENT: Store messages persistently
        LOCATION: backend/models.py (lines 348-390) - Message class
        
        TABLE: messages
        
        COLUMNS:
        ┌──────────────┬──────────────┬─────────────┐
        │ Column       │ Type         │ Description │
        ├──────────────┼──────────────┼─────────────┤
        │ id           │ Integer (PK) │ Message ID  │
        │ sender_id    │ Integer (FK) │ Sender user │
        │ receiver_id  │ Integer (FK) │ Receiver    │
        │ content      │ Text         │ Message     │
        │ is_read      │ Integer      │ 0=unread    │
        │ created_at   │ DateTime     │ Timestamp   │
        └──────────────┴──────────────┴─────────────┘
        
        INDEXES:
        - sender_id (for efficient queries)
        - receiver_id (for efficient queries)
        - created_at (for chronological sorting)
        
        RELATIONSHIPS:
        - One sender can have many messages (1-to-many)
        - One receiver can have many messages (1-to-many)
        - Foreign keys prevent orphaned messages

FR18.2 - Message Schemas (Pydantic)
        REQUIREMENT: Validate and serialize message data
        LOCATION: backend/schemas.py (lines 472-491)
        
        SCHEMA 1: MessageCreate (Input validation)
        ──────────────────────────────────────────
        
        class MessageCreate(BaseModel):
            receiverId: int   # Recipient user ID
            content: str      # Message text (required)
        
        USAGE: When sending POST /api/messages
        
        VALIDATION:
        - receiverId must be valid integer
        - content must not be empty
        - Receiver must exist in database
        
        
        SCHEMA 2: MessageResponse (Output format)
        ──────────────────────────────────────────
        
        class MessageResponse(BaseModel):
            id: int                    # Message ID
            senderId: int              # Sender user ID
            receiverId: int            # Receiver user ID
            content: str               # Message text
            createdAt: datetime        # Send timestamp
            isRead: int                # Read status (0/1)
        
        USAGE: API responses for both REST and WebSocket
        
        EXAMPLE RESPONSE:
        {
            "id": 42,
            "senderId": 1,
            "receiverId": 5,
            "content": "Is this still available?",
            "createdAt": "2025-11-22T16:30:00",
            "isRead": 0
        }

FR18.3 - Socket.IO Event Handlers
        REQUIREMENT: Handle real-time WebSocket events
        LOCATION: backend/main.py (lines 902-942)
        
        EVENT 1: connect
        ────────────────
        Triggered when: Browser connects via Socket.IO
        Handler code:
        
        @sio.event
        async def connect(sid, environ):
            print(f"Client connected: {sid}")
        
        Data structures: sid = unique socket connection ID
        
        
        EVENT 2: disconnect
        ───────────────────
        Triggered when: Browser disconnects or closes
        Handler code:
        
        @sio.event
        async def disconnect(sid):
            for user_id, socket_id in list(connected_users.items()):
                if socket_id == sid:
                    del connected_users[user_id]
        
        Purpose: Cleanup user from active connections
        
        
        EVENT 3: authenticate
        ─────────────────────
        Triggered when: Frontend emits authenticate after login
        Handler code:
        
        @sio.event
        async def authenticate(sid, data):
            user_id = data.get('userId')
            if user_id:
                connected_users[user_id] = sid
                await sio.emit('authenticated', {'status': 'ok'}, to=sid)
        
        Data structures:
        - connected_users: {user_id: socket_id}
        - Example: {1: 'socket123abc', 5: 'socket456def'}
        
        
        EVENT 4: send_message
        ─────────────────────
        Triggered when: Frontend sends message via Socket.IO
        Handler code:
        
        @sio.event
        async def send_message(sid, data, environ):
            receiver_id = data.get('receiverId')
            content = data.get('content')
            sender_id = data.get('senderId')
            
            # Broadcast to receiver if online
            if receiver_id in connected_users:
                await sio.emit('receive_message', {
                    'senderId': sender_id,
                    'content': content,
                    'timestamp': datetime.utcnow().isoformat()
                }, to=connected_users[receiver_id])
            
            # Confirm to sender
            await sio.emit('message_sent', {'status': 'success'}, to=sid)
        
        Flow:
        1. Check if receiver is online (in connected_users dict)
        2. If yes: Broadcast 'receive_message' event to receiver's socket
        3. Send 'message_sent' confirmation to sender
        4. NOTE: Does NOT save to database (REST API does that)

FR18.4 - REST API Endpoints for Messages
        REQUIREMENT: Fallback for offline users + message persistence
        
        ENDPOINT 1: POST /api/messages
        ──────────────────────────────
        
        PURPOSE: Send a message (REST API alternative to Socket.IO)
        LOCATION: backend/main.py (lines 948-998)
        
        REQUEST:
        POST /api/messages
        Authorization: Bearer <JWT_TOKEN>
        Content-Type: application/json
        
        {
            "receiverId": 5,
            "content": "Hi, is this available?"
        }
        
        VALIDATION:
        1. User must be authenticated (JWT token)
        2. Receiver must exist in database
        3. Content must not be empty
        
        RESPONSE (Success - 200):
        {
            "id": 42,
            "senderId": 1,
            "receiverId": 5,
            "content": "Hi, is this available?",
            "createdAt": "2025-11-22T16:30:00",
            "isRead": 0
        }
        
        PROCESS:
        1. Validate receiver exists
        2. Create Message object
        3. Save to messages table (database)
        4. Emit Socket.IO event if receiver online
        5. Return message with timestamp
        
        ERROR RESPONSES:
        - 401 Unauthorized: No valid token
        - 404 Not Found: Receiver doesn't exist
        - 422 Unprocessable Entity: Invalid data
        
        
        ENDPOINT 2: GET /api/messages/{user_id}
        ───────────────────────────────────────
        
        PURPOSE: Fetch message history with another user
        LOCATION: backend/main.py (lines 1000-1040)
        
        REQUEST:
        GET /api/messages/5
        Authorization: Bearer <JWT_TOKEN>
        
        PARAMETERS:
        - user_id (path parameter): ID of conversation partner
        
        RESPONSE (Success - 200):
        [
            {
                "id": 40,
                "senderId": 1,
                "receiverId": 5,
                "content": "Is this textbook available?",
                "createdAt": "2025-11-22T10:00:00",
                "isRead": 1
            },
            {
                "id": 41,
                "senderId": 5,
                "receiverId": 1,
                "content": "Yes! Still like new",
                "createdAt": "2025-11-22T10:05:00",
                "isRead": 0
            }
        ]
        
        QUERY LOGIC:
        - Fetches all messages WHERE:
          (sender_id = current_user AND receiver_id = user_id) OR
          (sender_id = user_id AND receiver_id = current_user)
        - Orders by created_at (oldest first)
        - Marks as read (is_read = 1) for current user
        
        AUTHORIZATION:
        - User must be authenticated
        - Can only fetch own messages (not other users')
        - Error: 401 if not authenticated
        
        USE CASE:
        When receiver was offline, message saved to database.
        When receiver logs in, frontend calls this endpoint
        to fetch all missed messages.

FR18.5 - Frontend Socket.IO Client Library
        REQUIREMENT: Enable client-side WebSocket support
        LOCATION: All 14 HTML files (added to <head>)
        
        CDN LIBRARY:
        <script src="https://cdn.socket.io/4.8.0/socket.io.min.js"></script>
        
        FILES UPDATED:
        1. index.html ✓
        2. messages.html ✓
        3. products.html ✓
        4. profile.html ✓
        5. saved-items.html ✓
        6. edit-profile.html ✓
        7. sell.html ✓
        8. login.html ✓
        9. signup.html ✓
        10. product-detail.html ✓
        11. about.html ✓
        12. coming-soon.html ✓
        13. signup-select-university.html ✓
        14. notifications.html ✓
        
        PLACEMENT: After Lucide icons CDN, before closing </head>
        
        PROVIDES:
        - window.io object for Socket.IO
        - Methods: socket.emit(), socket.on(), socket.disconnect()
        - Auto-reconnection support
        - Event handling infrastructure

FR18.6 - Complete Message Flow
        BOTH USERS ONLINE (Real-time):
        ──────────────────────────────
        
        1. User A logs in
           └─ Frontend: socket.emit('authenticate', {userId: 1})
        
        2. Backend receives authenticate
           └─ connected_users = {1: 'socket-A'}
        
        3. User B logs in
           └─ Frontend: socket.emit('authenticate', {userId: 5})
           └─ connected_users = {1: 'socket-A', 5: 'socket-B'}
        
        4. User A sends message
           └─ Socket.IO: emit('send_message', {...})
        
        5. Backend send_message handler
           └─ Check: receiver_id (5) in connected_users? YES
           └─ Emit 'receive_message' to User B's socket
        
        6. User B receives instantly
           └─ socket.on('receive_message') fires
           └─ Message appears in chat UI
        
        7. Message also saved to database
           └─ Persistence for message history
        
        
        USER A ONLINE, USER B OFFLINE (Fallback):
        ────────────────────────────────────────
        
        1. User A sends message
           └─ REST API: POST /api/messages
        
        2. Backend POST handler
           └─ Creates Message object
           └─ Saves to messages table
           └─ Check connected_users: receiver NOT FOUND
           └─ No real-time broadcast (offline)
        
        3. Message stays in database
           └─ When User B logs in
           └─ Frontend: GET /api/messages/1
           └─ Fetches all messages from database
           └─ History appears in chat

FR18.7 - User Presence Tracking
        REQUIREMENT: Track which users are online
        LOCATION: backend/main.py (line 900)
        
        DATA STRUCTURE:
        connected_users = {}  # Dictionary mapping user_id → socket_id
        
        EXAMPLE STATE:
        {
            1: 'socket-id-abc123',   # User 1 is online
            5: 'socket-id-def456',   # User 5 is online
            7: 'socket-id-ghi789'    # User 7 is online
        }
        
        OPERATIONS:
        
        Add user to connected (in authenticate event):
        connected_users[user_id] = sid
        
        Check if user online (in send_message):
        if receiver_id in connected_users:
            # User is online
        
        Remove user from connected (in disconnect event):
        del connected_users[user_id]
        
        GET SOCKET ID FOR USER:
        socket_id = connected_users.get(user_id)
        
        FUTURE ENHANCEMENTS:
        - Broadcast "user_online" event to all connected users
        - Show "User is typing..." indicator
        - Track last_seen timestamp for offline users
        - Implement read receipts (checkmarks)


================================================================================
3. NON-FUNCTIONAL REQUIREMENTS (NFR)
================================================================================

PERFORMANCE
===========

NFR1 - Page Load Time
       REQUIREMENT: Pages should load quickly
       TARGET: < 3 seconds initial load
       LOCATION: frontend/css/style.css, frontend/js/app.js
       IMPLEMENTATION:
       - Lazy loading for product images
       - CSS minification
       - Efficient database queries with indexes
       - Pagination (limit 20 items per page)
       - Caching: img lazy loading attributes

NFR2 - Database Query Optimization
       REQUIREMENT: Queries should be efficient
       LOCATION: backend/models.py (indexes on searchable columns)
       IMPLEMENTATION:
       - Index on Product.name (searchable)
       - Index on Product.created_at (sorting)
       - Index on User.email (login)
       - Index on User.username (login)
       - Relationships with lazy loading
       - JOIN queries instead of N+1 queries
       
       EXAMPLE: serialize_product() at backend/main.py (lines 277-321)
       - Single query fetches product with all related data
       - Relationships (images, seller, category) loaded efficiently

SECURITY
========

NFR3 - Password Hashing
       REQUIREMENT: Passwords encrypted using bcrypt
       LOCATION: backend/auth.py (get_password_hash, verify_password)
       STANDARD: bcrypt with 12 rounds
       PROTECTION:
       - Prevents rainbow table attacks (salting)
       - Prevents brute force attacks (intentionally slow)
       - One-way hashing (cannot decrypt, only verify)

NFR4 - JWT Token Security
       REQUIREMENT: API uses JWT tokens for stateless auth
       LOCATION: backend/auth.py (create_access_token, get_current_user)
       ALGORITHM: HS256 (HMAC-SHA256)
       EXPIRY: 7 days (604,800 seconds)
       TRANSMISSION: Authorization header with Bearer scheme
       STORAGE: Frontend localStorage (HttpOnly not available in frontend JS)
       
       PRODUCTION RECOMMENDATIONS:
       - Use HTTPS only (enforce in production)
       - Use HttpOnly cookies instead of localStorage
       - Store SECRET_KEY in environment variable (not hardcoded)
       - Rotate SECRET_KEY periodically
       - Implement refresh token rotation

NFR5 - SQL Injection Prevention
       REQUIREMENT: Protect against SQL injection attacks
       LOCATION: All database queries use SQLAlchemy ORM
       IMPLEMENTATION:
       - No raw SQL strings in code
       - Parameter binding through ORM
       - Pydantic validation on inputs
       - Example: db.query(Product).filter(Product.id == product_id)
       
       SQLAlchemy prevents SQL injection automatically

NFR6 - CORS (Cross-Origin Resource Sharing)
       REQUIREMENT: Frontend and backend on different ports (5000 vs 8000)
       LOCATION: backend/main.py (lines 71-77)
       IMPLEMENTATION:
       - CORS middleware allows all origins (development mode)
       - Frontend can call backend API without browser blocking
       - Production: Restrict to specific domain only
       
       CONFIGURATION:
       {
           "allow_origins": ["*"],      // Development
           "allow_credentials": true,   // Allow cookies
           "allow_methods": ["*"],      // Allow all HTTP methods
           "allow_headers": ["*"]       // Allow all headers
       }

NFR7 - Input Validation
       REQUIREMENT: All inputs validated before processing
       LOCATION: backend/schemas.py (Pydantic models)
       IMPLEMENTATION:
       - Type checking (int, str, etc.)
       - Length validation (min_length, max_length)
       - Pattern validation (email format)
       - Custom validators for business logic
       
       EXAMPLES:
       - Email validation: EmailStr (automatically validates)
       - Password length: Field(..., min_length=6, max_length=72)
       - Username length: Field(..., min_length=3, max_length=100)
       
       RESPONSE: 422 Unprocessable Entity if validation fails

USABILITY
=========

NFR8 - Responsive Design
       REQUIREMENT: Works on desktop, tablet, mobile
       LOCATION: frontend/css/style.css (media queries)
       BREAKPOINTS:
       - Mobile: < 768px
       - Tablet: 768px - 1024px
       - Desktop: > 1024px
       
       IMPLEMENTATION:
       - Flexible grid layouts
       - Mobile hamburger menu
       - Responsive images
       - Touch-friendly buttons

NFR9 - User Feedback & Loading States
       REQUIREMENT: Users see status of their actions
       LOCATION: frontend/signup.html, login.html
       IMPLEMENTATION:
       - Green loading spinner during submission
       - Success checkmark (green) on success
       - Error X (red) on failure
       - Success message persists, errors auto-dismiss after 3s
       - Prevents double-submission with disabled button

NFR10 - Real-time Image Previews
        REQUIREMENT: Users see preview before confirming upload
        LOCATION: frontend/edit-profile.html (image preview)
        LOCATION: frontend/sell.html (multiple image previews)
        IMPLEMENTATION:
        - FileReader API loads image as data URL
        - Shows preview before upload/save
        - Users can change selection
        - Only uploads after selection (no auto-upload for some)

MAINTAINABILITY
===============

NFR11 - Code Organization
        REQUIREMENT: Code well-organized and documented
        LOCATION: All files have header comments
        STRUCTURE:
        - backend/: FastAPI backend code
          * main.py: All API endpoints
          * models.py: Database table definitions
          * auth.py: Authentication logic
          * schemas.py: Request/response validation
          * database.py: Database connection
        - frontend/: HTML/CSS/JavaScript
          * *.html: Page templates
          * css/: Stylesheets
          * js/app.js: Global JavaScript
        
        FILE DOCUMENTATION:
        - Each file has header comment explaining purpose
        - Each function has docstring with parameters
        - Each class has docstring with relationships
        - Complex logic has inline comments

NFR12 - Database Design
        REQUIREMENT: Database schema is normalized
        LOCATION: backend/models.py
        RELATIONSHIPS:
        - University has many Users
        - User has many Products
        - User has many SavedItems
        - Product belongs to Category
        - Product belongs to User (seller)
        - Product has many ProductImages
        - ProductImage belongs to Product
        - SavedItem is junction table (User - Product)
        
        NORMALIZATION:
        - No data duplication
        - Foreign keys enforce referential integrity
        - Proper primary keys
        - Indexes on frequently searched columns

COMPATIBILITY
=============

NFR13 - Browser Compatibility
        REQUIREMENT: Works on modern browsers
        TESTED: Chrome, Firefox, Safari, Edge
        TECHNOLOGIES:
        - ES6 JavaScript (arrow functions, const/let, fetch API)
        - CSS Grid & Flexbox
        - HTML5 semantic elements
        - Lucide Icons via CDN
        
        FALLBACKS:
        - Progressive enhancement (works without JS, images lazy load)
        - Graceful degradation

NFR14 - Database Portability
        REQUIREMENT: Easy switch from SQLite to PostgreSQL
        LOCATION: backend/database.py
        IMPLEMENTATION:
        - Uses SQLAlchemy ORM (database-agnostic)
        - Connection string in environment variable
        - Same code works with SQLite or PostgreSQL
        - Migration: Only change DATABASE_URL
        
        PRODUCTION:
        - SQLite: sqlite:///./test.db (current)
        - PostgreSQL: postgresql://user:pass@host/dbname (production)


================================================================================
4. LEGAL & COMPLIANCE REQUIREMENTS
================================================================================

LR1 - Data Privacy
      REQUIREMENT: Student data protected
      IMPLEMENTATION:
      - Passwords hashed (cannot recover)
      - No plain text passwords in logs
      - No sensitive data in URLs
      - HTTPS recommended for production
      LOCATION: backend/auth.py - Password hashing

LR2 - Terms of Service Placeholder
      REQUIREMENT: Disclaimer for marketplace
      LOCATION: All pages have footer with links placeholder
      FUTURE: Implement terms, privacy policy, usage guidelines

LR3 - Content Moderation
      REQUIREMENT: Admin can moderate listings (future feature)
      CURRENT: Soft delete exists (status = "deleted")
      FUTURE: Admin dashboard, content reports

LR4 - User Verification
      REQUIREMENT: Only verified students can access
      IMPLEMENTATION: Email domain verification (@bazeuniversity.edu.ng)
      LOCATION: backend/main.py (lines 163-170)


================================================================================
5. SYSTEM ARCHITECTURE & METHODOLOGY
================================================================================

ARCHITECTURE DIAGRAM:
┌─────────────────────────────────────────────────────────────┐
│                  FRONTEND (Static HTML/CSS/JS)             │
│  ├─ Pages: signup, login, profile, products, sell, etc.   │
│  ├─ CSS: Responsive design, dark/light modes               │
│  └─ JS: Event handlers, API calls, local state (localStorage) │
└──────────────────┬──────────────────────────────────────────┘
                   │ HTTP/REST API
                   │ Port 5000 (Frontend Server)
                   │ Port 8000 (Backend API)
                   ▼
┌─────────────────────────────────────────────────────────────┐
│               BACKEND (FastAPI - Python)                    │
│  ├─ main.py: All HTTP endpoints                            │
│  ├─ models.py: Database schema (ORM)                       │
│  ├─ auth.py: Password & JWT security                       │
│  ├─ schemas.py: Request/response validation                │
│  └─ database.py: SQLAlchemy connection                     │
└──────────────────┬──────────────────────────────────────────┘
                   │ SQL Queries
                   ▼
┌─────────────────────────────────────────────────────────────┐
│              DATABASE (SQLite / PostgreSQL)                │
│  ├─ users: Student accounts                               │
│  ├─ products: Item listings                               │
│  ├─ product_images: Product photos                        │
│  ├─ categories: Product categories                        │
│  ├─ saved_items: Wishlist/bookmarks                       │
│  ├─ universities: University information                  │
│  └─ Relationships & Indexes for performance               │
└─────────────────────────────────────────────────────────────┘

TECHNOLOGY STACK:
Backend:
  - Framework: FastAPI (modern, fast Python web framework)
  - Database ORM: SQLAlchemy (database-agnostic)
  - Database: SQLite (dev), PostgreSQL (production-ready)
  - Authentication: JWT (stateless), bcrypt (password hashing)
  - API Documentation: Automatic Swagger UI at /docs
  
Frontend:
  - HTML5 (semantic markup)
  - CSS3 (flexbox, grid, responsive)
  - JavaScript ES6+ (vanilla, no frameworks)
  - Icons: Lucide Icons (CDN)
  - Storage: localStorage (client-side)
  
Security:
  - CORS: Enabled for dev, restricts for production
  - Password: bcrypt 12-round hashing
  - Tokens: JWT with 7-day expiry
  - Validation: Pydantic (automatic, comprehensive)

DEVELOPMENT METHODOLOGY
=======================

AGILE APPROACH:
- Iterative development with user feedback
- Feature-driven development
- Regular testing and refinement
- Version control: Git

TESTING APPROACH:
Manual Testing Performed:
- User registration and login flows
- Password validation and security
- Product creation with image requirements (3-5 images)
- Profile viewing and editing
- Access control (own profile vs others)
- Bookmark/save functionality
- Search and filtering
- Responsive design on mobile/tablet/desktop

TESTING SCENARIOS (Functional):
1. Registration:
   - Valid data → Creates account, auto-login
   - Invalid email domain → Rejects
   - Weak password → Rejects
   - Duplicate email → Rejects
   
2. Login:
   - Valid credentials → Returns token
   - Invalid password → Rejects with 401
   - Non-existent email → Rejects with 401
   
3. Products:
   - Create with 3+ images → Success
   - Create with <3 images → Rejects
   - Create with 6+ images → Rejects
   - Only owner can edit/delete
   
4. Profiles:
   - Account owner sees edit button
   - Other users see read-only profile
   - Profile picture optional until upload
   - Placeholder shown if no image

5. Permissions:
   - Saved items redirect to login if not authenticated
   - Protected endpoints return 401 if no token
   - Users can't edit others' products (403)
   - Users can't edit others' profiles (403)


================================================================================
5A. DETAILED DATABASE ARCHITECTURE & DESIGN
================================================================================

DATABASE OVERVIEW:
==================
UniMarket uses a relational database with 6 main tables organized in a 
normalized structure following Third Normal Form (3NF) principles.

DATABASE ARCHITECTURE & RATIONALE:
═══════════════════════════════════

DEVELOPMENT DATABASE: SQLite
────────────────────────────

WHY SQLite for Development:
───────────────────────────

1. ZERO CONFIGURATION OVERHEAD
   - SQLite requires NO installation, NO server setup, NO configuration
   - Single file (unimarket.db) contains entire database
   - Developers can work immediately without DevOps overhead
   - Perfect for rapid prototyping and testing during development

2. FAST ITERATION & DEVELOPMENT SPEED
   - No database server to start/stop
   - No network latency between app and database
   - Instant query results for debugging
   - Easy to reset/clear database for fresh testing
   - Can create multiple test databases by copying files

3. PORTABILITY & EASE OF SHARING
   - Single file can be committed to version control (for small databases)
   - Easy to backup: just copy the .db file
   - Easy to transfer between developers
   - Works on Windows, Mac, Linux identically
   - No docker containers or virtual machines needed

4. PERFECTLY ADEQUATE FOR SCOPE
   - UniMarket is a campus marketplace for ~5,000-10,000 students max
   - SQLite handles 100+ concurrent connections easily
   - Can store millions of rows efficiently
   - Development data is typically small (test data only)
   - During prototyping, data size/performance less critical than speed

5. EXCELLENT FOR FINAL YEAR PROJECT TESTING
   - Thesis defense/demo: Easy to reset database to initial state
   - Examiners can run tests without infrastructure setup
   - Database changes tracked in git for version control
   - No credentials or complex setup required for grading

6. SEAMLESS TRANSITION PLANNING
   - SQLAlchemy ORM abstracts database layer completely
   - Zero code changes needed to switch to PostgreSQL
   - Same models, same queries, same API - just change connection string
   - Allows development with SQLite, production deployment with PostgreSQL

IMPLEMENTATION:
- File: backend/unimarket.db (created automatically on first run)
- Engine: backend/database.py - SQLAlchemy engine with SQLite dialect
- Size: Grows as test data added (test database typically <10MB)
- Backup: Simple file copy for complete database backup

Code Location:
    backend/database.py (line ~30):
    DATABASE_URL = "sqlite:///./unimarket.db"
    engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})


PRODUCTION DATABASE: PostgreSQL
────────────────────────────────

WHY PostgreSQL for Production:
──────────────────────────────

1. ENTERPRISE-GRADE RELIABILITY
   - ACID compliance: All-or-Nothing transactions
   - Data integrity guaranteed across concurrent writes
   - PostgreSQL has 0 data corruption incidents in 30+ years
   - Designed for mission-critical systems (banks, government)
   - Real money transactions require bulletproof reliability

2. CONCURRENT USER SUPPORT
   - SQLite: ~1-2 concurrent writers max
   - PostgreSQL: Supports 1000+ concurrent connections
   - As UniMarket grows (100+ simultaneous users):
     * Multiple students buying/selling simultaneously
     * Multiple profile updates happening at once
     * Multiple image uploads in parallel
   - PostgreSQL handles all concurrency gracefully

3. ADVANCED SECURITY FEATURES
   - User-based access control (roles/permissions)
   - Row-level security policies
   - Encrypted passwords (pgcrypto extension)
   - SSL/TLS connections available
   - Audit logging of all changes
   - Protection against SQL injection (via parameterized queries)

4. SCALABILITY & PERFORMANCE
   - Full-text search: Can search product descriptions at lightning speed
   - Advanced indexing: B-tree, Hash, GiST, GIN indexes
   - Query optimization: Explains plans to analyze slow queries
   - Partitioning: Splits large tables for faster access
   - Replication: Primary-replica setup for redundancy
   - Connection pooling: Handles thousands of connections efficiently

5. ADVANCED DATA FEATURES
   - JSON/JSONB columns: Store complex product attributes
   - Arrays: Store multiple tags/categories per product
   - Custom types: Define domain-specific data types
   - Full-text search: Native support for searching products
   - Geometric types: Store user locations for proximity searches

6. DISASTER RECOVERY & BUSINESS CONTINUITY
   - Point-in-time recovery: Restore database to any second in past
   - WAL (Write-Ahead Logging): Protects data during crashes
   - Hot standby: Replica can take over instantly if primary fails
   - Automated backups: Hourly incremental backups possible
   - Critical for real marketplace where students depend on platform

7. COMPLIANCE & LEGAL REQUIREMENTS
   - Must comply with data protection regulations
   - PostgreSQL provides audit trails for compliance
   - Can implement row-level access control for privacy
   - Data retention policies easily enforced
   - GDPR-compliant backup/deletion procedures

WHY NOT MySQL/MariaDB:
   - PostgreSQL has better feature set for complex queries
   - PostgreSQL has superior ACID guarantees
   - PostgreSQL open-source with broader community
   - PostgreSQL often cheaper to host than MySQL

WHY NOT Cloud-Only Databases (DynamoDB, Firestore):
   - Would require complete rewrite of SQLAlchemy models
   - NoSQL doesn't fit relational data model of UniMarket
   - Relationships (user→products, products→images) need SQL joins
   - Cloud-only databases more expensive to scale
   - PostgreSQL gives same scalability at lower cost

IMPLEMENTATION:
- Engine: PostgreSQL 13+ (production servers typically use latest stable)
- Hosting: Cloud-managed databases (AWS RDS, Google Cloud SQL, Azure)
- Connection: SSL/TLS encrypted connections
- Backup: Daily automated backups (kept 30 days)
- Monitoring: Performance metrics and query analysis

Code Location:
    backend/database.py (updated for production):
    DATABASE_URL = "postgresql://user:password@host:5432/unimarket"
    engine = create_engine(DATABASE_URL, pool_size=20, max_overflow=40)


DATABASE ABSTRACTION LAYER: SQLAlchemy ORM
───────────────────────────────────────────

WHY Use SQLAlchemy for Both:
────────────────────────────

SINGLE CODEBASE, MULTIPLE DATABASES:
- Code is 100% database-agnostic
- SQLite in development works identically to PostgreSQL in production
- Same models (backend/models.py) work for both
- Same queries (backend/main.py) execute on both
- ZERO code changes when switching databases

SQL INJECTION PREVENTION:
- SQLAlchemy parameterizes all queries automatically
- Never concatenates user input into SQL strings
- Protects against malicious SQL: ' OR '1'='1
- Essential for marketplace storing financial data

TYPE SAFETY & VALIDATION:
- Python types catch errors before database
- SQLAlchemy validates data types on save
- Prevents storing wrong data types
- Automatic type conversion (string→int, etc.)

RELATIONSHIP MANAGEMENT:
- Foreign keys handled automatically
- User→Products relationship auto-populated
- Product→Images auto-joined when needed
- Cascading deletes prevent orphaned data
- No manual JOIN queries needed

Code Location:
    backend/database.py (lines 1-50):
    - Database configuration and connection setup
    backend/models.py (complete file):
    - SQLAlchemy ORM models for all tables


MIGRATION STRATEGY: SQLite → PostgreSQL
────────────────────────────────────────

To migrate from development to production:

Step 1: Setup PostgreSQL (done once)
  - Create database: createdb unimarket
  - Create user: createuser unimarket_admin
  - Grant permissions: GRANT ALL ON DATABASE unimarket

Step 2: Update connection string
  - Change DATABASE_URL in backend/database.py
  - From: sqlite:///./unimarket.db
  - To: postgresql://admin:password@host:5432/unimarket

Step 3: Create schema in PostgreSQL
  - Run Alembic migrations: alembic upgrade head
  - OR run: python create_database.py (creates all tables)
  - SQLAlchemy DDL creates identical schema

Step 4: Migrate existing data (if needed)
  - Export from SQLite: SELECT * FROM users;
  - Import to PostgreSQL: COPY users FROM 'users.csv';
  - OR use: python scripts/migrate_sqlite_to_postgres.py

Step 5: Update environment variable
  - Set DATABASE_URL in cloud platform environment config
  - Application automatically uses new connection string
  - NO code changes required

Step 6: Test thoroughly
  - Run same test suite on PostgreSQL
  - Verify all queries return same results
  - Performance should be significantly faster
  - No timeout issues with concurrent users

The beauty: Application code (backend/main.py) needs ZERO changes!


DEPLOYMENT PLATFORM: Cloud-Based Linux Server
═════════════════════════════════════════════════

WHY Cloud Platform (Linux Server) for Deployment:
──────────────────────────────────────────────────

1. ZERO INFRASTRUCTURE MANAGEMENT
   - No need to manage servers, networks, firewalls
   - Platform handles OS patches, security updates
   - Automatic scaling when traffic increases
   - No DevOps team needed (reduces cost)

2. IMMEDIATE GLOBAL AVAILABILITY
   - Your app accessible from anywhere on internet
   - Students can access from campus/home/anywhere
   - Platform handles DNS, domains, CDN
   - SSL/TLS certificates automatic
   - No need to buy/configure servers

3. COST-EFFECTIVE FOR STUDENT PROJECT
   - Pay-as-you-go pricing: Only pay for what you use
   - Free/cheap tiers perfect for thesis demo
   - No upfront hardware investment
   - Can scale as user base grows
   - Typically $5-20/month for small app

4. AUTOMATED DEPLOYMENT
   - Push code to git → Automatically deployed
   - No SSH, no manual build steps
   - Rollback to previous version with one click
   - Deployment takes minutes, not hours
   - Perfect for iterative development

5. BUILT-IN DATABASES & BACKUPS
   - Managed PostgreSQL/MySQL available
   - Automatic daily backups included
   - Point-in-time recovery possible
   - Datacenters in multiple regions
   - 99.9% uptime SLA guaranteed

6. SECURITY & COMPLIANCE
   - Platform manages security patches
   - DDoS protection included
   - Firewall rules automated
   - SSL/TLS required by default
   - Regular security audits
   - Meets compliance standards

7. MONITORING & DEBUGGING
   - Real-time error tracking
   - Performance monitoring dashboard
   - Database query analysis tools
   - Server logs available instantly
   - Alerts for problems

8. PERFECT FOR THESIS DEMONSTRATION
   - Live URL to show during defense
   - Examiners can test app from their computers
   - No setup required for grading
   - Data persists between grading sessions
   - Reliability and uptime matter for impression

WHY NOT Self-Hosted Server:
   - Would need to manage Linux server yourself
   - Responsible for security patches, updates
   - Backup strategy required and complex
   - Database maintenance manual and error-prone
   - SSL certificates manual and expensive
   - Downtime costly to your reputation
   - Scaling requires buying more hardware
   - DevOps knowledge required

WHY NOT Local Machine:
   - App not accessible from outside your network
   - No public URL to show examiners
   - Goes offline when computer shuts down
   - Internet connection issues cause downtime
   - Completely unsuitable for production

WHY NOT Expensive Enterprise Cloud (AWS, Azure):
   - Over-engineered for campus marketplace scope
   - Steep learning curve for students
   - Complex pricing with hidden fees
   - More infrastructure to manage
   - Overkill for thesis project demo
   - Cost: $50-500/month vs $5-20/month

DEPLOYMENT ARCHITECTURE:
────────────────────────

Your platform setup:
┌──────────────────────────────────────────────────────────┐
│                 CLOUD PLATFORM PROVIDER                  │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  LINUX CONTAINER/VM                               │ │
│  │                                                    │ │
│  │  ├─ Python 3.11                                   │ │
│  │  ├─ FastAPI Backend (port 8000)                   │ │
│  │  │  └─ /api/auth/* endpoints                      │ │
│  │  │  └─ /api/products/* endpoints                  │ │
│  │  │  └─ /api/users/* endpoints                     │ │
│  │  │  └─ /api/upload/* endpoints                    │ │
│  │  │                                                │ │
│  │  ├─ Python HTTP Server (port 5000)                │ │
│  │  │  └─ Serves static HTML/CSS/JS                  │ │
│  │  │  └─ Proxies /api/* to backend (8000)           │ │
│  │  │                                                │ │
│  │  └─ File Storage                                  │ │
│  │     └─ /uploads/products/* (product images)       │ │
│  │     └─ /uploads/avatars/* (profile pictures)      │ │
│  │                                                    │ │
│  └─────────────────────────────────────────────────────┘ │
│                           ▲                               │
│                           │                               │
│                    Managed by Platform:                  │
│              (Networking, Firewall, Routing)            │
│                                                           │
└──────────────────────────────────────────────────────────┘
              ▲
              │ Public Internet
              │
     ┌────────┴──────────┐
     │                   │
  Student Browser    Another Student
  (Chrome/Safari)    (Mobile App)

DEPLOYMENT PROCESS:
1. Developer pushes code to git
2. Platform detects changes
3. Pulls latest code
4. Installs dependencies (pip install -r requirements.txt)
5. Runs migrations (alembic upgrade head)
6. Starts application (uvicorn main:app)
7. Routes traffic to running app
8. App responds to requests from students

ZERO DOWNTIME UPDATES:
- Platform supports multiple replicas
- Updates happen rolling (one at a time)
- Traffic diverted to healthy instances
- Old instance stops after new one healthy
- Students experience zero interruption

DATABASE PERSISTENCE:
- While code changes with each git push
- Database persists across deployments
- PostgreSQL data survives app updates
- Student data never lost
- Perfect for continuous improvement

ENVIRONMENT CONFIGURATION:
- Sensitive data stored in platform secrets
- DATABASE_URL never hardcoded
- JWT_SECRET_KEY stored securely
- AWS credentials stored safely
- No secrets in git repository


DATABASE + DEPLOYMENT INTEGRATION:
═════════════════════════════════════

In Development:
    ┌─────────────────────────────────────────┐
    │  Your Local Machine                     │
    ├─────────────────────────────────────────┤
    │  FastAPI Backend + HTTP Server          │
    │  ↓                                       │
    │  backend/unimarket.db (SQLite file)     │
    │                                         │
    │  Perfect for debugging & development    │
    └─────────────────────────────────────────┘

In Production:
    ┌─────────────────────────────────────────┐
    │  Cloud Platform (Linux)                 │
    ├─────────────────────────────────────────┤
    │  FastAPI Backend + HTTP Server (2-4x)   │
    │  ↓                                       │
    │  PostgreSQL (Managed DB Service)        │
    │  │                                       │
    │  ├─ Automatic backups (daily)            │
    │  ├─ Replication (high availability)      │
    │  ├─ Monitoring & alerts                  │
    │  ├─ Point-in-time recovery               │
    │                                         │
    │  Perfect for reliability & scalability  │
    └─────────────────────────────────────────┘

COST ANALYSIS:
──────────────

Development (SQLite):
    - File-based: $0 (just storage on your computer)
    - Perfect for thesis work, exams, demos

Production (PostgreSQL on Cloud):
    - Small instance (1-2 GB RAM): $10-15/month
    - Database backups: Included
    - SSL certificates: Included
    - CDN & DDoS protection: Included
    - 99.9% uptime SLA: Included
    
    Much cheaper than:
    - Self-managed VPS: $30-50/month + DevOps time
    - AWS without managed DB: $100-500/month
    - Enterprise hosting: $500+/month

Scaling Example:
    - 100 users: $10-15/month
    - 1,000 users: $15-30/month
    - 10,000 users: $50-100/month
    
    Auto-scaling handles traffic spikes


WHY THIS ARCHITECTURE WORKS PERFECTLY FOR UNIMARKET:
═════════════════════════════════════════════════════

1. DEVELOPMENT SPEED
   ✅ SQLite rapid iteration without configuration
   ✅ Cloud platform instant deployment after testing
   ✅ No infrastructure overhead

2. THESIS DEMONSTRATION
   ✅ Live public URL to show examiners
   ✅ No setup/installation required by graders
   ✅ Data persists across multiple viewing sessions
   ✅ Automatic backups protect student data

3. PRODUCTION-READINESS
   ✅ PostgreSQL handles enterprise-grade requirements
   ✅ Cloud platform ensures 99.9% uptime
   ✅ Automatic scaling for traffic growth
   ✅ Security & compliance built-in

4. COST EFFICIENCY
   ✅ Free/cheap during development
   ✅ Low cost even if app grows
   ✅ No hardware investment
   ✅ No DevOps team needed

5. FUTURE EXTENSIBILITY
   ✅ Cloud platform easily adds: email, SMS, payments
   ✅ PostgreSQL supports advanced features if needed
   ✅ Multi-region deployment possible
   ✅ Mobile app backend ready

ARCHITECTURE CONCLUSION:
"""
UniMarket's architecture (SQLite→PostgreSQL + Cloud Linux)
is IDEAL for a final year project because it:

- Requires ZERO system administration
- Lets developer focus on FEATURES, not infrastructure
- Provides IMMEDIATE global deployment
- Scales from thesis demo to production-grade app
- Costs PENNIES to run during development
- Enables examiners to test app LIVE during defense
- Remains MAINTAINABLE and EXTENSIBLE for years

This is professional-grade architecture that companies
use in production, adapted for student project scope.
"""


ENTITY-RELATIONSHIP (ER) DIAGRAM:
==================================

This is the complete database structure showing all tables and relationships:

┌─────────────────────────────────────────────────────────────────────┐
│                         UNIVERSITIES TABLE                         │
├─────────────────────────────────────────────────────────────────────┤
│ id (PK)             → Integer, unique identifier                   │
│ name                → "Baze University", "Lagos State University"  │
│ domain              → "@bazeuniversity.edu.ng" (UNIQUE)            │
│                                                                     │
│ Purpose: Organize users by university, enforce email domains       │
│ Relationships: ←── User (one uni has many users)                   │
└─────────────────────────────────────────────────────────────────────┘
                              ▲
                              │ ONE
                              │
                        ONE │ university_id (FK)
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          USERS TABLE                               │
├─────────────────────────────────────────────────────────────────────┤
│ id (PK)              → Integer, auto-increment                     │
│ full_name            → "John Doe" (2-255 chars, required)          │
│ username             → "johndoe" (3-100 chars, UNIQUE, indexed)    │
│ email                → "john@bazeuniversity.edu.ng" (UNIQUE, idx) │
│ password_hash        → bcrypt hash (never plain text!)             │
│ university_id (FK)   → Points to universities.id                   │
│ bio                  → Optional biography (Text, nullable)         │
│ profile_image        → URL to avatar (/uploads/products/*.jpg)     │
│ phone                → Optional phone number                       │
│ created_at           → Timestamp when account created              │
│                                                                     │
│ Purpose: Store user accounts and profiles                          │
│ Relationships:                                                      │
│   ├──→ University (many users per uni)                            │
│   ├──→ Product (user can create many products)                    │
│   └──→ SavedItem (user can save many products)                    │
└─────────────────────────────────────────────────────────────────────┘
        ▲                              ▲                    ▲
        │ ONE                          │ ONE               │ ONE
        │                              │                   │
    id (PK)                      seller_id (FK)        user_id (FK)
        │ MANY                         │ MANY             │ MANY
        │                              ▼                   ▼
        │              ┌────────────────────────────────────────┐
        └─────────────→│        PRODUCTS TABLE                  │
                       ├────────────────────────────────────────┤
                       │ id (PK)                → Auto-increment │
                       │ name                   → Product name   │
                       │ description            → Full details   │
                       │ price                  → Float (₦ price)│
                       │ category_id (FK)       → Category link  │
                       │ seller_id (FK)  ──────→ Who sells it   │
                       │ location               → Location (Baze)│
                       │ condition              → New/Like New.. │
                       │ size                   → Optional (S,M)│
                       │ color                  → Optional color │
                       │ status      → "available"/"sold"/"del" │
                       │ created_at, updated_at → Timestamps    │
                       │                                        │
                       │ Purpose: Store product listings         │
                       │ Relationships:                          │
                       │   ├──→ User (seller)                   │
                       │   ├──→ Category                        │
                       │   ├──→ ProductImage (1 to many)       │
                       │   └──→ SavedItem (many saved by users) │
                       └────────────────────────────────────────┘
                                ▲           ▲
                                │ ONE       │ ONE
                                │           │
                      product_id (FK)  category_id (FK)
                                │ MANY       │ MANY
                                │           │
                    ┌──────────────┐    ┌──────────────┐
                    │ PRODUCT_     │    │  CATEGORIES  │
                    │ IMAGES TABLE │    │  TABLE       │
                    ├──────────────┤    ├──────────────┤
                    │ id (PK)      │    │ id (PK)      │
                    │ product_id   │    │ name (UNIQUE)│
                    │ image_url    │    │              │
                    │ is_primary   │    │ Purpose:     │
                    │ created_at   │    │ Organize     │
                    │              │    │ products by  │
                    │ Purpose:     │    │ category     │
                    │ Store images │    │              │
                    │ for products │    │ Relationships│
                    │ (3-5 per     │    │   Product    │
                    │ product)     │    │   (many)     │
                    │              │    │              │
                    │ Relationships│    └──────────────┘
                    │ → Product    │
                    └──────────────┘
                                ▲
                                │
                         product_id (FK)
                                │
                       ┌─────────────────────────────────┐
                       │   SAVED_ITEMS TABLE             │
                       │   (Many-to-Many Junction)       │
                       ├─────────────────────────────────┤
                       │ id (PK)      → Auto-increment   │
                       │ user_id (FK) → Which user saved │
                       │ product_id   → Which product    │
                       │ created_at   → When saved       │
                       │                                 │
                       │ Purpose: Link users to saved    │
                       │ products (wishlist/bookmarks)   │
                       │                                 │
                       │ Relationships:                  │
                       │   ├──→ User (bookmark list)     │
                       │   └──→ Product (saved by users) │
                       └─────────────────────────────────┘


TABLE SPECIFICATIONS & DETAILS:
================================

1. UNIVERSITIES TABLE
   Location: backend/models.py (lines 55-82)
   Rows: 1-5 (one per supported university)
   
   PURPOSE: Define allowed universities and their email domains
   
   COLUMNS:
   ┌─────────────┬──────────────┬────────────────────────────┐
   │ Column      │ Type         │ Details                    │
   ├─────────────┼──────────────┼────────────────────────────┤
   │ id (PK)     │ Integer      │ Primary key, indexed       │
   │ name        │ String(255)  │ "Baze University"          │
   │ domain      │ String(255)  │ @bazeuniversity.edu.ng     │
   │             │              │ UNIQUE (no duplicates)     │
   └─────────────┴──────────────┴────────────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id (automatic)
   - UNIQUE on domain (automatic)
   
   INITIAL DATA (SEEDED):
   - ID: 1, Name: "Baze University", Domain: "bazeuniversity.edu.ng"
   
   QUERIES:
   - Get uni by email domain: SELECT * FROM universities WHERE domain = "@bazeuniversity.edu.ng"
   - Get all unis: SELECT * FROM universities


2. USERS TABLE
   Location: backend/models.py (lines 87-151)
   Rows: Grows with each signup (1 row per student)
   
   PURPOSE: Store student accounts, authentication, and profile info
   
   COLUMNS:
   ┌──────────────────┬──────────────┬─────────────────────────┐
   │ Column           │ Type         │ Details                 │
   ├──────────────────┼──────────────┼─────────────────────────┤
   │ id (PK)          │ Integer      │ Auto-increment          │
   │ full_name        │ String(255)  │ Real name, required     │
   │ username         │ String(100)  │ UNIQUE, indexed, login  │
   │ email            │ String(255)  │ UNIQUE, indexed         │
   │ password_hash    │ String(255)  │ bcrypt hash (72 chars)  │
   │ university_id    │ Integer (FK) │ Foreign key to univ.    │
   │ bio              │ Text         │ Optional biography      │
   │ profile_image    │ String(500)  │ Avatar URL, nullable    │
   │ phone            │ String(20)   │ Phone number, optional  │
   │ created_at       │ DateTime     │ Account creation time   │
   └──────────────────┴──────────────┴─────────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id
   - UNIQUE on username (fast login lookups)
   - UNIQUE on email (prevent duplicate emails)
   - FOREIGN KEY on university_id (referential integrity)
   
   CONSTRAINTS:
   - full_name: NOT NULL (required)
   - username: NOT NULL, UNIQUE (required, no duplicates)
   - email: NOT NULL, UNIQUE (required, no duplicates)
   - password_hash: NOT NULL (required)
   - university_id: NOT NULL, FOREIGN KEY
   
   EXAMPLE ROW:
   ┌────┬──────────────┬────────┬──────────────────────────────┬──────┐
   │ id │ full_name    │ uname  │ email                        │ ... │
   ├────┼──────────────┼────────┼──────────────────────────────┼──────┤
   │ 1  │ John Doe     │ john   │ john@bazeuniversity.edu.ng   │ ... │
   │ 2  │ Jane Smith   │ jane   │ jane@bazeuniversity.edu.ng   │ ... │
   └────┴──────────────┴────────┴──────────────────────────────┴──────┘
   
   QUERIES:
   - Login: SELECT * FROM users WHERE email = ? (indexed)
   - Find by username: SELECT * FROM users WHERE username = ? (indexed)
   - Get user profile: SELECT * FROM users WHERE id = ?
   - Count users per uni: SELECT COUNT(*) FROM users WHERE university_id = 1


3. CATEGORIES TABLE
   Location: backend/models.py (lines 156-178)
   Rows: 5 (fixed)
   
   PURPOSE: Define product categories for organization
   
   COLUMNS:
   ┌─────────┬──────────────┬──────────────────────┐
   │ Column  │ Type         │ Details              │
   ├─────────┼──────────────┼──────────────────────┤
   │ id (PK) │ Integer      │ Auto-increment       │
   │ name    │ String(100)  │ UNIQUE, "Textbooks" │
   └─────────┴──────────────┴──────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id
   - UNIQUE on name (fast lookups by category)
   
   INITIAL DATA (SEEDED):
   - ID: 1, Name: "Textbooks"
   - ID: 2, Name: "Electronics"
   - ID: 3, Name: "Clothing"
   - ID: 4, Name: "Furniture"
   - ID: 5, Name: "Other"
   
   QUERIES:
   - List all categories: SELECT * FROM categories
   - Get products in category: SELECT * FROM products WHERE category_id = 2


4. PRODUCTS TABLE
   Location: backend/models.py (lines 183-264)
   Rows: Grows with each listing (1 row per product)
   
   PURPOSE: Store product listings
   
   COLUMNS:
   ┌──────────────┬──────────────┬──────────────────────────┐
   │ Column       │ Type         │ Details                  │
   ├──────────────┼──────────────┼──────────────────────────┤
   │ id (PK)      │ Integer      │ Auto-increment           │
   │ name         │ String(255)  │ Product name, indexed    │
   │ description  │ Text         │ Long product details     │
   │ price        │ Float        │ Price in Nigerian Naira  │
   │ category_id  │ Integer (FK) │ Category link            │
   │ seller_id    │ Integer (FK) │ Who's selling (user.id)  │
   │ location     │ String(255)  │ Where located, optional  │
   │ condition    │ String(50)   │ New/Like New/Good/Fair   │
   │ size         │ String(50)   │ Size (for clothing)      │
   │ color        │ String(50)   │ Color, optional          │
   │ status       │ String(50)   │ available/sold/deleted   │
   │ created_at   │ DateTime     │ When listed              │
   │ updated_at   │ DateTime     │ Last modified            │
   └──────────────┴──────────────┴──────────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id
   - INDEX on name (for search queries)
   - INDEX on created_at (for sorting)
   - FOREIGN KEY on category_id
   - FOREIGN KEY on seller_id
   
   EXAMPLE ROW:
   ┌────┬──────────────────┬───────┬────────────┬────┬──────────────┐
   │ id │ name             │ price │ seller_id  │... │ status       │
   ├────┼──────────────────┼───────┼────────────┼────┼──────────────┤
   │ 1  │ Calculus Book    │ 3500  │ 1          │... │ available    │
   │ 2  │ Laptop           │ 45000 │ 2          │... │ available    │
   │ 3  │ Old Textbook     │ 1500  │ 1          │... │ sold         │
   └────┴──────────────────┴───────┴────────────┴────┴──────────────┘
   
   SOFT DELETE STRATEGY:
   - Product never actually deleted from database
   - status = "deleted" hides it from queries
   - Can be restored later if needed
   - Preserves history for analytics
   
   QUERIES:
   - List all available: SELECT * FROM products WHERE status = "available"
   - Search by name: SELECT * FROM products WHERE name LIKE %search%
   - User's products: SELECT * FROM products WHERE seller_id = 1
   - Filter by category & price: SELECT * FROM products WHERE category_id = 2 AND price BETWEEN 0 AND 5000


5. PRODUCT_IMAGES TABLE
   Location: backend/models.py (lines 269-305)
   Rows: 3-5 per product (3-5 images required per listing)
   
   PURPOSE: Store image URLs for products (one-to-many relationship)
   
   COLUMNS:
   ┌──────────────┬──────────────┬──────────────────────────┐
   │ Column       │ Type         │ Details                  │
   ├──────────────┼──────────────┼──────────────────────────┤
   │ id (PK)      │ Integer      │ Auto-increment           │
   │ product_id   │ Integer (FK) │ Which product owns this  │
   │ image_url    │ String(500)  │ Full path to image       │
   │ is_primary   │ Integer      │ 1 = main image, 0 = not  │
   │ created_at   │ DateTime     │ When uploaded            │
   └──────────────┴──────────────┴──────────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id
   - FOREIGN KEY on product_id (cascade delete)
   
   CASCADE DELETE:
   - If product is deleted, all images deleted too
   - Prevents orphaned image records
   
   EXAMPLE ROWS (for Product ID 1):
   ┌────┬──────────────┬───────────────────────────────┬────────────┐
   │ id │ product_id   │ image_url                     │ is_primary │
   ├────┼──────────────┼───────────────────────────────┼────────────┤
   │ 1  │ 1            │ /uploads/products/uuid1.jpg   │ 1          │
   │ 2  │ 1            │ /uploads/products/uuid2.jpg   │ 0          │
   │ 3  │ 1            │ /uploads/products/uuid3.jpg   │ 0          │
   └────┴──────────────┴───────────────────────────────┴────────────┘
   
   IMAGE STORAGE:
   - Location: backend/uploads/products/
   - Filename: UUID + original extension (e.g., 3fa85f64-5717-4562.jpg)
   - No overwrites: UUID ensures unique filenames
   - HTTP path: /uploads/products/3fa85f64-5717-4562.jpg
   
   QUERIES:
   - Get all images for product: SELECT * FROM product_images WHERE product_id = 1
   - Get primary image: SELECT * FROM product_images WHERE product_id = 1 AND is_primary = 1


6. SAVED_ITEMS TABLE (Many-to-Many Junction)
   Location: backend/models.py (lines 310-343)
   Rows: Grows with each bookmark (no limit)
   
   PURPOSE: Link users to products they've saved (wishlist)
   
   COLUMNS:
   ┌──────────────┬──────────────┬──────────────────────────┐
   │ Column       │ Type         │ Details                  │
   ├──────────────┼──────────────┼──────────────────────────┤
   │ id (PK)      │ Integer      │ Auto-increment           │
   │ user_id      │ Integer (FK) │ Which user saved it      │
   │ product_id   │ Integer (FK) │ Which product was saved  │
   │ created_at   │ DateTime     │ When saved               │
   └──────────────┴──────────────┴──────────────────────────┘
   
   INDEXES:
   - PRIMARY KEY on id
   - FOREIGN KEY on user_id
   - FOREIGN KEY on product_id
   - UNIQUE constraint on (user_id, product_id) pair
   
   EXAMPLE ROWS:
   ┌────┬─────────┬────────────┬──────────────────────┐
   │ id │ user_id │ product_id │ created_at           │
   ├────┼─────────┼────────────┼──────────────────────┤
   │ 1  │ 1       │ 5          │ 2025-11-22 10:30:00  │
   │ 2  │ 1       │ 10         │ 2025-11-22 10:45:00  │
   │ 3  │ 2       │ 5          │ 2025-11-22 11:00:00  │
   └────┴─────────┴────────────┴──────────────────────┘
   
   MANY-TO-MANY PATTERN:
   - One user can save many products
   - One product can be saved by many users
   - This junction table connects them
   
   QUERIES:
   - Get user's saved items: SELECT p.* FROM products p JOIN saved_items s ON p.id = s.product_id WHERE s.user_id = 1
   - Check if user saved product: SELECT * FROM saved_items WHERE user_id = 1 AND product_id = 5
   - Get who saved a product: SELECT u.* FROM users u JOIN saved_items s ON u.id = s.user_id WHERE s.product_id = 5


DATA FLOW & RELATIONSHIPS:
==========================

1. USER REGISTRATION FLOW:
   ┌──────────────┐
   │ Frontend     │ POST /api/auth/register
   │ signup.html  │────────────────────────→ Backend API
   └──────────────┘                         ├─ Validate email domain
                                            ├─ Hash password with bcrypt
                                            ├─ Check username/email unique
                                            └─ INSERT into users table
                                                ↓
                                           ┌────────────────────┐
                                           │ USERS TABLE        │
                                           │ New row created    │
                                           │ with user data     │
                                           └────────────────────┘

2. PRODUCT CREATION FLOW:
   ┌──────────────┐
   │ Frontend     │ 1. POST /api/upload (3-5 images)
   │ sell.html    │────────────────────────→ Backend
   └──────────────┘                         ├─ Validate image files
                                            ├─ Save to /uploads/products/
                                            └─ Return URLs
                                                ↓
                                           Returns image URLs
                                                ↓
                                        2. POST /api/products
                                           ├─ INSERT into products table
                                           ├─ INSERT into product_images table (3-5 rows)
                                           └─ Return product object

3. PRODUCT SEARCH FLOW:
   ┌──────────────────────┐
   │ Frontend             │ GET /api/products?search=book&category=1&priceMax=5000
   │ products.html        │─────────────────────→ Backend
   └──────────────────────┘                      ├─ Query products table
                                                 ├─ Filter by name LIKE
                                                 ├─ Filter by category_id
                                                 ├─ Filter by price range
                                                 ├─ JOIN with product_images
                                                 ├─ JOIN with users (seller info)
                                                 └─ Return product array
                                                      ↓
                                                ┌────────────────────┐
                                                │ Products returned  │
                                                │ with images &      │
                                                │ seller info        │
                                                └────────────────────┘

4. BOOKMARK/SAVED ITEMS FLOW:
   ┌──────────────────────┐
   │ Frontend             │ POST /api/saved-items/toggle
   │ product-detail.html  │────────────────────────→ Backend
   └──────────────────────┘                        ├─ Check if already saved
                                                   ├─ If not: INSERT into saved_items
                                                   ├─ If yes: DELETE from saved_items
                                                   └─ Return toggle result


NORMALIZATION & DESIGN PRINCIPLES:
===================================

DATABASE NORMALIZATION (3NF):
The schema follows Third Normal Form (3NF):

1. First Normal Form (1NF):
   ✓ All columns contain atomic (indivisible) values
   ✓ No repeating groups
   ✓ Example: Product images in separate table, not array in product row

2. Second Normal Form (2NF):
   ✓ All non-key attributes depend on the entire primary key
   ✓ No partial dependencies
   ✓ Example: product_images.image_url depends on product_id

3. Third Normal Form (3NF):
   ✓ No transitive dependencies
   ✓ Non-key attributes depend only on primary key
   ✓ Example: categories.name not in products (avoids data duplication)

BENEFITS OF NORMALIZATION:
- Eliminates data redundancy (saves space)
- Maintains data integrity (one source of truth)
- Simplifies updates (change once, everywhere)
- Prevents anomalies (insertion, deletion, update)

DENORMALIZATION DECISIONS:
Some columns could be denormalized for performance:
- Example: Storing category_name directly in products table
- Trade-off: Save query joins vs. data consistency risk
- Current decision: Keep normalized (correctness > performance)
- Future: Cache layer (Redis) for performance if needed


INDEXES & PERFORMANCE:
======================

CURRENT INDEXES:
┌─────────────────┬──────────┬────────────────────────────┐
│ Table           │ Column   │ Purpose                    │
├─────────────────┼──────────┼────────────────────────────┤
│ users           │ id       │ Primary key (auto)         │
│ users           │ username │ Fast login lookups         │
│ users           │ email    │ Fast email lookups         │
│ products        │ id       │ Primary key (auto)         │
│ products        │ name     │ Search by product name     │
│ products        │ created_ │ Sort by newest first       │
│                 │ at       │                            │
│ categories      │ id       │ Primary key (auto)         │
│ categories      │ name     │ Fast category lookups      │
│ universities    │ id       │ Primary key (auto)         │
│ universities    │ domain   │ Unique email domains       │
└─────────────────┴──────────┴────────────────────────────┘

INDEX STRATEGY:
- Index all primary keys (automatic)
- Index all foreign keys (for JOIN performance)
- Index columns used in WHERE clauses (search, filter)
- Index columns used in ORDER BY (sorting)
- Index UNIQUE columns (enforces uniqueness, speeds lookup)

QUERY OPTIMIZATION:
Slow query example:
  SELECT * FROM products WHERE name LIKE '%book%'
  (Without index: scans all rows)

Fast query example:
  SELECT * FROM products WHERE id = 1
  (With index: instant lookup)

Future optimization:
  - Database: Add composite indexes
  - Example: INDEX on (seller_id, created_at) for "user's products sorted by date"
  - Add full-text search index for product names
  - Use EXPLAIN ANALYZE to identify slow queries


DATABASE STATISTICS:
====================

Storage Capacity (SQLite):
- Theoretical limit: 140 TB (very large!)
- Practical limit: Depends on host storage
- Current usage: < 1 MB (empty database)

Scale Estimates:
- 1,000 users: ~200 KB
- 10,000 products: ~500 KB
- 100,000 products: ~5 MB

When to migrate to PostgreSQL:
- > 10,000 products
- > 100 concurrent users
- Need replication/backup
- Need advanced features (full-text search, JSON, etc.)


DATABASE MIGRATION PLAN (SQLite → PostgreSQL):
===============================================

The architecture is designed for easy migration:

Step 1: Set environment variable
  export DATABASE_URL="postgresql://user:pass@host:5432/unimarket"

Step 2: No code changes needed!
  - SQLAlchemy handles it automatically
  - All ORM queries remain identical
  - No SQL to rewrite

Step 3: Initialize PostgreSQL
  - Create database: CREATE DATABASE unimarket;
  - Run: python -c "from backend.database import init_db; init_db()"
  - Tables created automatically
  - Data seeded automatically

Step 4: Migrate existing SQLite data (if needed)
  - Export from SQLite
  - Import to PostgreSQL
  - Tools: pgloader, python script with SQLAlchemy


BACKUP & RECOVERY:
==================

SQLite Backup (development):
- File: unimarket.db
- Backup: Copy the file
- Restore: Replace with backup copy

PostgreSQL Backup (production):
  # Backup
  pg_dump unimarket > backup.sql
  
  # Restore
  psql unimarket < backup.sql

Automated backups (recommended for production):
- AWS RDS automated backups
- Daily PostgreSQL dumps
- Replicate to S3 or cloud storage


================================================================================
6. IMPLEMENTATION CHECKLIST & CODE LOCATIONS
================================================================================

AUTHENTICATION SYSTEM
✅ User Registration
   Location: backend/main.py (116-188) - register()
   Location: frontend/signup.html

✅ User Login
   Location: backend/main.py (190-246) - login()
   Location: frontend/login.html

✅ Password Hashing (bcrypt)
   Location: backend/auth.py (85-117) - get_password_hash()
   Location: backend/auth.py (55-83) - verify_password()

✅ JWT Token Generation
   Location: backend/auth.py (123-155) - create_access_token()

✅ JWT Token Verification
   Location: backend/auth.py (156-200) - get_current_user()

✅ Email Domain Validation
   Location: backend/main.py (163-170) - University domain check

✅ Password Strength Requirements
   Location: frontend/signup.html - regex validation
   Location: frontend/login.html - show/hide toggle

✅ Auto-Login After Signup
   Location: frontend/signup.html (~150-160)

✅ Logout Functionality
   Location: frontend/js/app.js (244-250) - logout()


PRODUCT MANAGEMENT
✅ Create Listing
   Location: backend/main.py (325-370) - create_product()
   Location: frontend/sell.html

✅ Image Upload (3-5 required)
   Location: backend/main.py (721-765) - upload_image()
   Location: frontend/sell.html - validation

✅ View Products (with search/filter)
   Location: backend/main.py (372-430) - list_products()
   Location: frontend/products.html

✅ View Product Details
   Location: backend/main.py (432-460) - get_product()
   Location: frontend/product-detail.html

✅ Edit Product (owner only)
   Location: backend/main.py (462-540) - update_product()

✅ Delete Product (soft delete)
   Location: backend/main.py (542-570) - delete_product()


USER PROFILES
✅ View Profile (any user)
   Location: backend/main.py (642-670) - get_user()
   Location: frontend/profile.html

✅ Edit Profile (owner only)
   Location: backend/main.py (672-720) - update_user()
   Location: frontend/edit-profile.html

✅ Profile Picture Upload
   Location: backend/main.py (721-765) - upload_image()
   Location: frontend/edit-profile.html

✅ Access Control
   Location: frontend/profile.html - Show/hide buttons based on owner
   Location: frontend/edit-profile.html - Owner-only page
   Location: frontend/saved-items.html - Redirects if not logged in


SAVED ITEMS
✅ Bookmark Product
   Location: backend/main.py (572-610) - toggle_saved_item()
   Location: frontend/product-detail.html

✅ View Saved Items (owner only)
   Location: backend/main.py (612-640) - get_saved_items()
   Location: frontend/saved-items.html


NAVIGATION & UI
✅ Dynamic Navbar (logged in vs out)
   Location: frontend/js/app.js (181-200) - updateNavbarAuthState()
   Location: frontend/index.html (48-73)
   Location: frontend/products.html (59-81)

✅ Loading States & Feedback
   Location: frontend/signup.html - Status indicator
   Location: frontend/login.html - Status indicator

✅ Image Previews
   Location: frontend/edit-profile.html - Avatar preview
   Location: frontend/sell.html - Product image previews


DATABASE
✅ User Table
   Location: backend/models.py (87-151) - User class

✅ Product Table
   Location: backend/models.py (183-264) - Product class

✅ Product Images
   Location: backend/models.py (269-305) - ProductImage class

✅ Saved Items
   Location: backend/models.py (310-342) - SavedItem class

✅ Categories
   Location: backend/models.py (156-178) - Category class

✅ Universities
   Location: backend/models.py (55-82) - University class


================================================================================
7. FUTURE ENHANCEMENTS & SCALABILITY
================================================================================

PLANNED FEATURES:
1. Messaging System (real-time chat between buyer/seller)
2. Rating & Review System (seller reputation)
3. Payment Integration (Stripe, Paystack, etc.)
4. Order Management (track transactions)
5. Admin Dashboard (moderate content, view analytics)
6. Push Notifications
7. Email Notifications
8. Advanced Search (filters, saved searches)
9. Recommendation Engine (suggestions based on browsing)
10. Multi-university Support (expand to other schools)

SCALABILITY IMPROVEMENTS:
1. Redis Caching (speed up frequent queries)
2. Image CDN (serve images from edge servers)
3. Database Replication (failover & reliability)
4. Load Balancing (distribute traffic)
5. Microservices (separate auth, products, messaging)
6. Elasticsearch (advanced full-text search)
7. WebSockets (real-time updates)
8. Message Queue (background jobs)

PERFORMANCE OPTIMIZATION:
1. Database query optimization (indexes, eager loading)
2. API response compression (gzip)
3. Frontend bundling (minify JS/CSS)
4. Image optimization (resize, compress)
5. Lazy loading (load content on demand)
6. Caching strategy (Redis for sessions, HTTP caching)

DEPLOYMENT IMPROVEMENTS:
1. CI/CD Pipeline (automated testing & deployment)
2. Environment Configuration (different configs for dev/prod)
3. SSL/TLS Certificate (HTTPS)
4. Database Migrations (version control for schema)
5. Logging & Monitoring (track errors, performance)
6. Backup & Recovery (protect data)


================================================================================
8. REQUIREMENTS TRACEABILITY MATRIX
================================================================================

REQUIREMENT ID → CODE LOCATION

FR1 (Registration) → backend/main.py:116-188 | frontend/signup.html
FR1.1 (Password Req) → frontend/signup.html | frontend/js validation
FR1.2 (Auto-login) → frontend/signup.html:150-160
FR2 (Login) → backend/main.py:190-246 | frontend/login.html
FR2.1 (Token Security) → backend/auth.py:156-200
FR3 (Password Hash) → backend/auth.py:85-117
FR4 (JWT Auth) → backend/auth.py:156-200
FR5 (Email Domain) → backend/main.py:163-170
FR6 (Create Product) → backend/main.py:325-370 | frontend/sell.html
FR6.1 (Image Validation) → backend/main.py:480-485 | frontend/sell.html
FR6.2 (Image Upload) → backend/main.py:721-765
FR7 (Browse/Search) → backend/main.py:372-430 | frontend/products.html
FR7.1 (Search) → backend/main.py:390-410
FR7.2 (Filtering) → backend/main.py:412-428
FR7.3 (Sorting) → backend/main.py:429-430
FR8 (Product Details) → backend/main.py:432-460 | frontend/product-detail.html
FR9 (Update Product) → backend/main.py:462-540
FR10 (Delete Product) → backend/main.py:542-570
FR11 (Save Items) → backend/main.py:572-610
FR12 (View Saved) → backend/main.py:612-640 | frontend/saved-items.html
FR13 (Profile) → backend/main.py:642-670 | frontend/profile.html
FR13.1 (Edit Profile) → backend/main.py:672-720 | frontend/edit-profile.html
FR14 (Picture Upload) → backend/main.py:721-765 | frontend/edit-profile.html
FR15 (Dynamic Navbar) → frontend/js/app.js:181-200
FR16 (Logout) → frontend/js/app.js:244-250

NFR1 (Performance) → frontend/css/style.css | backend/models.py indexes
NFR2 (Query Optimization) → backend/models.py indexes
NFR3 (Password Hashing) → backend/auth.py:85-117
NFR4 (JWT Security) → backend/auth.py | backend/main.py CORS
NFR5 (SQL Injection) → All backend uses SQLAlchemy ORM
NFR6 (CORS) → backend/main.py:71-77
NFR7 (Input Validation) → backend/schemas.py
NFR8 (Responsive Design) → frontend/css/style.css media queries
NFR9 (User Feedback) → frontend/signup.html, login.html status indicator
NFR10 (Image Preview) → frontend/edit-profile.html, sell.html
NFR11 (Code Organization) → All files have header comments
NFR12 (Database Design) → backend/models.py entire file
NFR13 (Browser Compatibility) → Modern browser standard features
NFR14 (Database Portability) → backend/database.py

LR1 (Data Privacy) → backend/auth.py password handling
LR2 (Terms Placeholder) → footer on all pages
LR3 (Content Moderation) → Soft delete in product deletion
LR4 (User Verification) → backend/main.py:163-170 email domain

================================================================================
9. TESTING SUMMARY
================================================================================

Manual Testing Completed:
1. ✅ User can sign up with valid email and password
2. ✅ User can log in with correct credentials
3. ✅ User rejected if email doesn't match domain
4. ✅ User rejected if password weak
5. ✅ User auto-logged in after signup
6. ✅ User can create product with 3-5 images
7. ✅ User rejected if <3 or >5 images
8. ✅ User can view own profile with edit button
9. ✅ User can view others' profiles (read-only)
10. ✅ User can upload profile picture
11. ✅ User can edit profile (name, bio)
12. ✅ User can search products
13. ✅ User can filter by category, price, condition
14. ✅ User can bookmark/save products
15. ✅ User can view saved items (owner only)
16. ✅ Navbar shows icons when logged in
17. ✅ Navbar shows buttons when logged out
18. ✅ User can logout
19. ✅ Password visibility toggle works
20. ✅ Loading indicators work

Automated Testing:
- Not currently implemented
- Recommendation: Add pytest for backend (unit & integration tests)
- Recommendation: Add Jest for frontend (component & integration tests)


================================================================================
10. CODE DOCUMENTATION STRATEGY
================================================================================

DOCUMENTATION STANDARDS APPLIED:

1. FILE HEADER (top of each file)
   - What the file does
   - Key components/endpoints
   - Where to find specific features
   
2. FUNCTION DOCSTRINGS (above each function)
   - What the function does
   - Parameters (name, type, description)
   - Return value (type, example)
   - Validation rules
   - Error responses
   - Example request/response JSON
   
3. CLASS DOCSTRINGS (above each class)
   - What the class represents
   - Columns/attributes with descriptions
   - Relationships to other tables
   - Usage examples
   
4. INLINE COMMENTS (in code)
   - Complex logic explanation
   - "Why" not just "what"
   - Security-critical sections
   - Performance considerations
   
5. CODE LOCATION MAPPING
   - This document maps every requirement to code location
   - Developers can find any feature instantly
   - Cross-references between frontend/backend


DOCUMENTATION LOCATIONS:
- Backend code docs: inline + header comments
- Frontend code docs: inline + header comments
- Requirements mapping: THIS FILE (THESIS_CHAPTER_3_REQUIREMENTS.txt)
- API Docs: Auto-generated at http://localhost:8000/docs (Swagger UI)


================================================================================
11. UML DIAGRAMS & VISUAL SYSTEM DESIGN
================================================================================

OVERVIEW:
=========
This section contains comprehensive UML diagrams showing how users interact with
the system, how data flows through the application, and how the system components
are organized and communicate.


================================================================================
11.1 USE CASE DIAGRAM
================================================================================

ACTORS:
- Student (Registered User)
- Seller (Student creating products)
- Buyer (Student browsing/purchasing)
- System (Backend/Database)

USE CASE DIAGRAM - UNIMARKET SYSTEM:

                              ┌─────────────────────────────────────┐
                              │      UNIMARKET SYSTEM               │
                              │                                     │
                              │  ┌───────────────────────────────┐ │
        ┌──────────────┐       │  │     AUTHENTICATION            │ │
        │              │       │  │  ┌─────────────────────────┐ │ │
        │   STUDENT    │──────────→│  │  UC1: Register Account  │ │ │
        │  (All Users) │       │  │  └─────────────────────────┘ │ │
        │              │       │  │  ┌─────────────────────────┐ │ │
        └──────────────┘       │  │  │  UC2: Login             │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             ├─────────────────→│  │  │  UC3: Logout            │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  └───────────────────────────────┘ │
             │                 │                                    │
             │                 │  ┌───────────────────────────────┐ │
             │                 │  │  PROFILE MANAGEMENT            │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC4: View Profile      │ │ │
             │                 ├─────→  (Own or Others)         │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC5: Edit Profile      │ │ │
             │                 ├─────→  (Owner Only)            │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC6: Upload Avatar     │ │ │
             │                 ├─────→  (Owner Only)            │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  └───────────────────────────────┘ │
             │                 │                                    │
             │                 │  ┌───────────────────────────────┐ │
             │                 │  │  PRODUCT MANAGEMENT            │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC7: Create Listing    │ │ │
             │                 ├─────→  (with 3-5 images)      │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC8: View Products     │ │ │
             │                 ├──────→  (Browse All)           │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC9: Search Products   │ │ │
             │                 ├──────→  (by name, category)    │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC10: Filter Products  │ │ │
             │                 ├──────→  (price, condition)     │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC11: View Details     │ │ │
             │                 ├──────→  (Single product)       │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC12: Edit Listing     │ │ │
             │                 ├─────→  (Owner Only)            │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC13: Delete Listing   │ │ │
             │                 ├─────→  (Owner Only)            │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  └───────────────────────────────┘ │
             │                 │                                    │
             │                 │  ┌───────────────────────────────┐ │
             │                 │  │  WISHLIST/BOOKMARKS            │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC14: Save Product     │ │ │
             │                 ├──────→  (to wishlist)          │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC15: View Saved Items │ │ │
             │                 ├──────→  (Owner Only)           │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  │  ┌─────────────────────────┐ │ │
             │                 │  │  │  UC16: Remove Bookmark  │ │ │
             │                 ├──────→  (Owner Only)           │ │ │
             │                 │  │  └─────────────────────────┘ │ │
             │                 │  └───────────────────────────────┘ │
             │                 │                                    │
             └─────────────────→│  ┌───────────────────────────────┐ │
                                │  │  SYSTEM FUNCTIONS             │ │
                                │  │  ┌─────────────────────────┐ │ │
                                │  │  │  Validate Email Domain  │ │ │
                                │  │  │  Hash Passwords         │ │ │
                                │  │  │  Generate JWT Tokens    │ │ │
                                │  │  │  Process Images         │ │ │
                                │  │  └─────────────────────────┘ │ │
                                │  └───────────────────────────────┘ │
                                │                                     │
                                └─────────────────────────────────────┘


================================================================================
11.2 USE CASE DICTIONARY
================================================================================

UC1: REGISTER ACCOUNT (User Authentication)
────────────────────────────────────────────
Primary Actor: Student (New User)
Precondition: Student has valid @bazeuniversity.edu.ng email
Postcondition: Account created, token issued, user logged in

Main Flow:
1. Student clicks "Sign Up"
2. System displays registration form
3. Student enters: full name, email, username, password, confirm password
4. System validates email domain (must be @bazeuniversity.edu.ng)
5. System validates password strength (6+ chars, 1 uppercase, 1 number)
6. System checks username/email uniqueness
7. System hashes password with bcrypt
8. System creates user record in database
9. System generates JWT token
10. System auto-logs in student
11. System redirects to profile page

Exception Flows:
- Invalid email domain → Display error "Email must be @bazeuniversity.edu.ng"
- Weak password → Display error "Password must have 6+ chars, 1 uppercase, 1 number"
- Duplicate username → Display error "Username already taken"
- Duplicate email → Display error "Email already registered"

Code Location: backend/main.py (lines 116-188) - register()
Frontend: signup.html


UC2: LOGIN (User Authentication)
─────────────────────────────────
Primary Actor: Student (Registered User)
Precondition: User account exists
Postcondition: JWT token issued, user data stored in localStorage

Main Flow:
1. Student clicks "Log In"
2. System displays login form
3. Student enters email and password
4. System finds user by email
5. System verifies password using bcrypt
6. System generates JWT token (expires in 7 days)
7. System returns token + user data
8. Frontend stores token in localStorage
9. Frontend stores user data in localStorage
10. Navbar updates to show logged-in state
11. System redirects to products page

Exception Flows:
- User not found → Display error "Invalid email or password"
- Password incorrect → Display error "Invalid email or password"
- Email doesn't exist → Display error "Invalid email or password"

Code Location: backend/main.py (lines 190-246) - login()
Frontend: login.html


UC3: LOGOUT (User Authentication)
──────────────────────────────────
Primary Actor: Student (Logged-in User)
Precondition: User is logged in (token in localStorage)
Postcondition: User session cleared, logged out

Main Flow:
1. Student clicks "Logout" button
2. Frontend removes token from localStorage
3. Frontend removes user data from localStorage
4. Frontend updates navbar to show logged-out state
5. Frontend redirects to home page

Code Location: frontend/js/app.js (lines 244-250)


UC4: VIEW PROFILE (Profile Management)
───────────────────────────────────────
Primary Actor: Student (Any user)
Precondition: User account exists
Postcondition: Profile information displayed

Main Flow:
1. Student clicks profile icon or username
2. System loads user profile data (name, bio, avatar, stats)
3. System displays "My Listings" tab (current user's products)
4. System displays product grid
5. If user is owner: Show "Edit Profile" and "Saved Items" buttons
6. If user is visitor: Show read-only profile

Code Location: backend/main.py (lines 642-670) - get_user()
Frontend: profile.html


UC5: EDIT PROFILE (Profile Management - Owner Only)
───────────────────────────────────────────────────
Primary Actor: Student (Profile Owner)
Precondition: User is logged in and viewing own profile
Postcondition: Profile updated in database

Main Flow:
1. Profile owner clicks "Edit Profile" button
2. System loads current profile data
3. Owner enters new: full name, bio, avatar URL
4. Owner clicks "Save Changes"
5. System validates new data
6. System updates user record in database
7. System updates localStorage with new data
8. System redirects to profile page
9. Profile displays updated information

Authorization: Only owner can edit (checked by backend)

Code Location: backend/main.py (lines 672-720) - update_user()
Frontend: edit-profile.html


UC6: UPLOAD AVATAR (Profile Management)
────────────────────────────────────────
Primary Actor: Student (Profile Owner)
Precondition: User on Edit Profile page
Postcondition: Avatar uploaded and stored

Main Flow:
1. Owner clicks camera icon
2. File picker opens (image files only)
3. Owner selects image file
4. System shows instant preview
5. System automatically uploads to /api/upload
6. Backend saves image to backend/uploads/products/
7. Backend returns image URL
8. Frontend stores URL for profile update
9. When profile saved, avatar URL sent with other data

Accepted Formats: JPEG, PNG, GIF, WebP, SVG, etc.
Default: Placeholder icon until image uploaded

Code Location: backend/main.py (lines 721-765) - upload_image()
Frontend: edit-profile.html


UC7: CREATE LISTING (Product Management)
─────────────────────────────────────────
Primary Actor: Student (Seller)
Precondition: User is logged in
Postcondition: Product created and visible in marketplace

Main Flow:
1. Seller clicks "New Listing" button
2. System displays product form
3. Seller enters: name, description, price, category, condition
4. Seller optionally enters: size, color
5. Seller uploads 3-5 product images (REQUIRED)
6. System validates image count (must be exactly 3-5)
7. For each image: Upload to /api/upload
8. Backend returns image URLs
9. Seller clicks "Create Listing"
10. System validates all fields
11. System creates product record
12. System creates 3-5 product_images records
13. Product appears in marketplace

Validation Rules:
- Product name: 1-255 characters
- Description: 1-5000 characters
- Price: 0-10,000,000 (₦)
- Category: Must select (Textbooks, Electronics, Clothing, Furniture, Other)
- Condition: Must select (New, Like New, Good, Fair)
- Images: MUST be 3-5 images (red X if <3, red X if >5, green checkmark if 3-5)

Code Location: backend/main.py (lines 325-370) - create_product()
Frontend: sell.html


UC8: VIEW PRODUCTS (Product Browsing)
──────────────────────────────────────
Primary Actor: Student (Buyer)
Precondition: None (can view without login)
Postcondition: Product grid displayed

Main Flow:
1. Student clicks "Shop" or visits products.html
2. System fetches all available products from API
3. System displays product grid (responsive layout)
4. Each product card shows: image, name, price (₦), meta info
5. Student can scroll/paginate to see more products
6. Clicking product card → UC11: View Details

Code Location: backend/main.py (lines 372-430) - list_products()
Frontend: products.html


UC9: SEARCH PRODUCTS (Product Browsing)
────────────────────────────────────────
Primary Actor: Student (Buyer)
Precondition: On products page
Postcondition: Filtered product list displayed

Main Flow:
1. Student types in search box (e.g., "textbook")
2. System filters products by name and description
3. System displays matching products
4. Search is case-insensitive
5. Real-time filtering (updates as user types)

Example:
- Search "book" → Shows all products with "book" in name/description
- Search "laptop" → Shows all laptops and computer-related products

Code Location: backend/main.py (lines 390-410) - Search logic in list_products()
Frontend: products.html (JavaScript search implementation)


UC10: FILTER PRODUCTS (Product Browsing)
─────────────────────────────────────────
Primary Actor: Student (Buyer)
Precondition: On products page
Postcondition: Filtered product list displayed

Main Flow:
1. Student selects filters from sidebar:
   - Category: Textbooks, Electronics, Clothing, Furniture, Other
   - Price Range: Min ₦ to Max ₦ (slider ₦0-₦10,000)
   - Condition: New, Like New, Good, Fair
2. System applies all selected filters (AND logic)
3. System updates product grid with matching items
4. Filters are combinable (e.g., Electronics + Condition: New)
5. "View All Products" link clears all filters

Example Filter Combinations:
- Category: Electronics AND Price: ₦0-₦5,000 AND Condition: Like New
- Category: Clothing AND Condition: Good

Code Location: backend/main.py (lines 412-428) - Filter logic in list_products()
Frontend: products.html (filter panel)


UC11: VIEW PRODUCT DETAILS (Product Browsing)
──────────────────────────────────────────────
Primary Actor: Student (Buyer)
Precondition: Product exists and is available
Postcondition: Full product details displayed

Main Flow:
1. Student clicks product card from grid
2. System loads product details page
3. System displays:
   - Product images (gallery with thumbnails)
   - Product name, price (₦), condition, size, color
   - Full description
   - Seller info (name, username, avatar, stats)
   - Category, location (Baze University)
   - Save/bookmark button
4. Student can:
   - Click images to view in full size
   - Click seller name to view seller's profile (UC4)
   - Click bookmark to save (UC14)

Code Location: backend/main.py (lines 432-460) - get_product()
Frontend: product-detail.html


UC12: EDIT LISTING (Product Management - Owner Only)
──────────────────────────────────────────────────────
Primary Actor: Student (Seller/Owner)
Precondition: User owns the product
Postcondition: Product updated in database

Main Flow:
1. Owner visits own product page
2. Owner sees "Edit" button (only if owner)
3. Owner clicks "Edit"
4. System loads product form with current data
5. Owner modifies: name, description, price, condition, images, etc.
6. Owner clicks "Update"
7. System validates all fields
8. System updates product record
9. System updates product_images if images changed
10. System redirects to product page
11. Updated product shows new information

Authorization: Only product seller can edit

Code Location: backend/main.py (lines 462-540) - update_product()


UC13: DELETE LISTING (Product Management - Owner Only)
───────────────────────────────────────────────────────
Primary Actor: Student (Seller/Owner)
Precondition: User owns the product
Postcondition: Product status changed to "deleted" (soft delete)

Main Flow:
1. Owner visits own product page
2. Owner sees "Delete" button
3. Owner clicks "Delete"
4. System asks for confirmation
5. System changes product status from "available" to "deleted"
6. Product no longer appears in marketplace searches
7. Owner's "My Listings" no longer shows deleted product
8. Product can be restored later (future feature)

Soft Delete Strategy:
- Product not permanently removed from database
- Soft delete preserves history for analytics
- Can be restored in future feature

Authorization: Only product seller can delete

Code Location: backend/main.py (lines 542-570) - delete_product()


UC14: SAVE PRODUCT (Wishlist/Bookmarks)
────────────────────────────────────────
Primary Actor: Student (Buyer)
Precondition: Product exists, user is logged in
Postcondition: Product saved to user's wishlist

Main Flow:
1. Student views product details
2. Student clicks bookmark icon
3. System checks if user is logged in
4. If not logged in: Redirect to login
5. If logged in: Toggle save status
6. If product not saved: Create saved_item record
7. If product already saved: Delete saved_item record
8. Bookmark icon updates (filled vs outlined)
9. Product appears in user's "Saved Items"

Code Location: backend/main.py (lines 572-610) - toggle_saved_item()
Frontend: product-detail.html, products.html


UC15: VIEW SAVED ITEMS (Wishlist - Owner Only)
───────────────────────────────────────────────
Primary Actor: Student (Logged-in User)
Precondition: User is logged in
Postcondition: Saved products displayed

Main Flow:
1. Student clicks "Saved" button (bookmark icon)
2. System checks authentication
3. If not logged in: Redirect to login
4. If logged in: Fetch user's saved items from API
5. System displays grid of saved products
6. Each product card shows: image, name, price, bookmark icon
7. Clicking bookmark removes product
8. Clicking product card → UC11: View Details

Authorization: Only account owner can view their saved items

Empty State:
- If no saved items: Display "You have no saved items"
- Show "Start Browsing" button linking to products page

Code Location: backend/main.py (lines 612-640) - get_saved_items()
Frontend: saved-items.html, profile.html (Saved tab)


UC16: REMOVE BOOKMARK (Wishlist)
─────────────────────────────────
Primary Actor: Student (Owner)
Precondition: Product is in user's saved items
Postcondition: Product removed from saved items

Main Flow:
1. Student viewing saved items page
2. Student clicks bookmark icon on product card
3. System removes saved_item record from database
4. Product disappears from grid immediately
5. Bookmark icon toggles back to outlined

Alternative:
- Can also remove while viewing product details (UC11)

Code Location: backend/main.py (lines 572-610) - toggle_saved_item() (DELETE)


================================================================================
11.3 DATA FLOW DIAGRAMS (DFD)
================================================================================

CONTEXT LEVEL (DFD-0) - SYSTEM BOUNDARY:
═════════════════════════════════════════

This shows UniMarket system as a single bubble with external actors.

                         ┌──────────────────┐
                         │    STUDENT       │
                         │   USER/BUYER     │
                         │                  │
                         └────────┬─────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
            (Browse Products)        (Create Listings, Edit Profile)
                    │                           │
        ┌───────────┴───────────────────────────┴──────────────┐
        │                                                       │
        │        ┌─────────────────────────────────────┐       │
        │        │                                     │       │
        │        │       UNIMARKET SYSTEM             │       │
        │        │   (Peer-to-Peer Marketplace)       │       │
        │        │                                     │       │
        │        │  • Authentication                   │       │
        │        │  • Product Management               │       │
        │        │  • User Profiles                    │       │
        │        │  • Search & Filter                  │       │
        │        │  • Wishlist/Bookmarks               │       │
        │        │                                     │       │
        │        └──────────────┬──────────────────────┘       │
        │                       │                              │
        └───────────────────────┼──────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    │                       │
                    ▼                       ▼
            (Products, Users,    (Storage for profile
             Messages, Wishlist)  pictures, product images)
                    │                       │
            ┌───────┴────────┐      ┌──────┴──────────┐
            │                │      │                 │
            ▼                ▼      ▼                 ▼
        ┌──────────┐  ┌──────────┐ ┌──────────────────────┐
        │ DATABASE │  │  EXTERNAL│ │  FILE STORAGE        │
        │(SQLite/  │  │  EMAIL   │ │  (/uploads/products) │
        │PostgreSQL)  │VERIFICATION│ │                     │
        │          │  │(future)   │ └──────────────────────┘
        └──────────┘  └──────────┘


LEVEL 0 (DFD-0) - MAJOR PROCESSES:
═══════════════════════════════════

                    ┌─────────────────┐
                    │   STUDENT USER  │
                    │                 │
                    └────────┬────────┘
                             │
          ┌──────────────────┼──────────────────┐
          │                  │                  │
          ▼                  ▼                  ▼
    (Auth Request)    (Product Data)   (Profile Request)
          │                  │                  │
          │                  │                  │
    ┌─────┴──────┐    ┌──────┴───────┐  ┌──────┴──────┐
    │             │    │              │  │             │
    │ 1.0         │    │  2.0         │  │  3.0        │
    │ AUTHENTICATE    │  PRODUCT       │  │ PROFILE     │
    │ USER        │    │  MANAGEMENT   │  │ MANAGEMENT  │
    │             │    │              │  │             │
    │ •Register   │    │ •Create      │  │ •View       │
    │ •Login      │    │ •Search      │  │ •Edit       │
    │ •Logout     │    │ •Filter      │  │ •Upload     │
    │             │    │ •View        │  │  Avatar     │
    │             │    │ •Update      │  │             │
    │             │    │ •Delete      │  │             │
    └─────┬──────┘    └──────┬───────┘  └──────┬──────┘
          │                  │                  │
          │                  ├──────────┬───────┤
          │                  │          │       │
          └──────────────────┼──────────┤       │
                             │          │       │
                          ┌──┴──────────┴──┐   │
                          │                │   │
                          │ 4.0            │   │
                          │ WISHLIST       │   │
                          │ MANAGEMENT     │   │
                          │                │   │
                          │ •Save Product  │   │
                          │ •View Saved    │   │
                          │ •Remove        │   │
                          │                │   │
                          └────────────────┘   │
                                               │
                          ┌────────────────────┘
                          │
                          ▼
                    ┌──────────────┐
                    │  DATA STORE  │
                    │  (Database)  │
                    │              │
                    │ D1: Users    │
                    │ D2: Products │
                    │ D3: Images   │
                    │ D4: Saved    │
                    │ D5: Categories
                    │              │
                    └──────────────┘


LEVEL 1 (DFD-1) - DETAILED USER AUTHENTICATION:
════════════════════════════════════════════════

┌────────────────────────────────────────────────────────────────────┐
│                          REGISTRATION FLOW                         │
└────────────────────────────────────────────────────────────────────┘

  STUDENT              FRONTEND             BACKEND              DATABASE
     │                    │                    │                    │
     │─── Form Data ─────→│                    │                    │
     │  (Name, Email,     │                    │                    │
     │   Pass, etc.)      │                    │                    │
     │                    │                    │                    │
     │                    │── Validate Form ──→│                    │
     │                    │  Data              │                    │
     │                    │                    │                    │
     │                    │                    │─ Check Email ─────→│
     │                    │                    │ Domain             │
     │                    │                    │                    │
     │                    │                    │←─ Domain Valid ────│
     │                    │                    │                    │
     │                    │                    │─ Check Username ──→│
     │                    │                    │ Uniqueness         │
     │                    │                    │                    │
     │                    │                    │←─ Unique OK ───────│
     │                    │                    │                    │
     │                    │                    │─ Hash Password ────│
     │                    │                    │ (bcrypt)           │
     │                    │                    │                    │
     │                    │                    │─ Insert User ─────→│
     │                    │                    │ Record             │
     │                    │                    │                    │
     │                    │                    │←─ User Created ────│
     │                    │                    │                    │
     │                    │                    │─ Generate JWT ─────│
     │                    │                    │ Token              │
     │                    │                    │                    │
     │                    │←── Token + Data ───│                    │
     │                    │                    │                    │
     │←── Success + Token ─│                    │                    │
     │                    │                    │                    │
     │─ Store Token ─────→│                    │                    │
     │  in localStorage   │                    │                    │
     │                    │                    │                    │
     │←── Auto-Login ─────│                    │                    │
     │                    │                    │                    │


================================================================================
11.4 SEQUENCE DIAGRAMS
================================================================================

SEQUENCE: USER REGISTRATION & AUTO-LOGIN
═════════════════════════════════════════

User             Frontend          Backend API         Database
  │                  │                  │                  │
  │─ Enter Data ────→│                  │                  │
  │ (signup form)    │                  │                  │
  │                  │                  │                  │
  │                  │─ POST /register ─→│                  │
  │                  │  (validation)     │                  │
  │                  │                  │                  │
  │                  │                  │─ Validate Email ─→│
  │                  │                  │ Domain            │
  │                  │                  │←─ Domain OK ──────│
  │                  │                  │                  │
  │                  │                  │─ Hash Password ──→│
  │                  │                  │ (bcrypt)          │
  │                  │                  │                  │
  │                  │                  │─ Create User ────→│
  │                  │                  │                  │
  │                  │                  │←─ User Created ───│
  │                  │                  │                  │
  │                  │←─ 201 Created ────│                  │
  │                  │  + JWT Token      │                  │
  │                  │  + User Data      │                  │
  │                  │                  │                  │
  │←─ Show Success ──│                  │                  │
  │  (Green Checkmark)                  │                  │
  │                  │                  │                  │
  │                  │─ POST /login ────→│                  │
  │                  │ (Auto-login)      │                  │
  │                  │                  │                  │
  │                  │                  │─ Verify Password ─→ (DB check)
  │                  │                  │                  │
  │                  │←─ 200 OK ─────────│                  │
  │                  │  + Token          │                  │
  │                  │  + User Data      │                  │
  │                  │                  │                  │
  │←─ Auto-Login ────│                  │                  │
  │  Success         │                  │                  │
  │                  │                  │                  │
  │ (Redirect to Profile)               │                  │
  │                  │                  │                  │


SEQUENCE: PRODUCT CREATION WITH IMAGE UPLOAD
═════════════════════════════════════════════

Seller           Frontend          Backend API        File Storage      Database
  │                  │                  │                  │                │
  │─ Select Images ─→│                  │                  │                │
  │ (3-5 images)     │                  │                  │                │
  │                  │                  │                  │                │
  │                  │─ POST /upload ───→│                  │                │
  │                  │  (Image 1)        │                  │                │
  │                  │                  │                  │                │
  │                  │                  │─ Save Image ────→│                │
  │                  │                  │ (UUID filename)   │                │
  │                  │                  │←─ Saved OK ──────│                │
  │                  │                  │                  │                │
  │                  │←─ Image URL ──────│                  │                │
  │                  │  (for Image 1)    │                  │                │
  │                  │                  │                  │                │
  │                  │─ POST /upload ───→│ (Repeat for Image 2, 3, 4, 5)    │
  │                  │                  │                  │                │
  │  (User fills product form with all images loaded)      │                │
  │                  │                  │                  │                │
  │─ Submit Form ────→│                  │                  │                │
  │ (name, desc,     │                  │                  │                │
  │  images URLs)    │                  │                  │                │
  │                  │                  │                  │                │
  │                  │─ POST /products ─→│                  │                │
  │                  │ (product data)    │                  │                │
  │                  │                  │                  │                │
  │                  │                  │─ Create Product ─→│                │
  │                  │                  │ Record            │                │
  │                  │                  │←─ Product ID ────│                │
  │                  │                  │                  │                │
  │                  │                  │─ Create 5 Image ─→│                │
  │                  │                  │ Records           │                │
  │                  │                  │                  │                │
  │                  │                  │←─ Images Created ─│                │
  │                  │                  │                  │                │
  │                  │←─ 201 Created ────│                  │                │
  │                  │  + Product Data   │                  │                │
  │                  │                  │                  │                │
  │←─ Success ───────│                  │                  │                │
  │  Redirect to     │                  │                  │                │
  │  Profile Page    │                  │                  │                │
  │                  │                  │                  │                │


SEQUENCE: SEARCH & FILTER PRODUCTS
═══════════════════════════════════

Buyer            Frontend          Backend API        Database
  │                  │                  │                │
  │─ Type Search ───→│                  │                │
  │ (e.g., "book")   │                  │                │
  │                  │                  │                │
  │                  │─ GET /products ──→│                │
  │                  │ ?search=book      │                │
  │                  │                  │                │
  │                  │                  │─ Query by Name ─→
  │                  │                  │ and Description  │
  │                  │                  │←─ Results ──────│
  │                  │                  │                │
  │                  │←─ 200 OK ────────│                │
  │                  │  Product Array    │                │
  │                  │                  │                │
  │←─ Display Grid ──│                  │                │
  │ (matching books) │                  │                │
  │                  │                  │                │
  │─ Select Filters ─→│                  │                │
  │ (Category,       │                  │                │
  │  Price Range)    │                  │                │
  │                  │                  │                │
  │                  │─ GET /products ──→│                │
  │                  │ ?search=book&     │                │
  │                  │ category=1&       │                │
  │                  │ priceMax=5000     │                │
  │                  │                  │                │
  │                  │                  │─ Query with ───→
  │                  │                  │ Multiple Filters │
  │                  │                  │←─ Results ──────│
  │                  │                  │                │
  │                  │←─ 200 OK ────────│                │
  │                  │  Filtered Array   │                │
  │                  │                  │                │
  │←─ Display Grid ──│                  │                │
  │ (filtered by     │                  │                │
  │  category+price) │                  │                │
  │                  │                  │                │


================================================================================
11.5 ACTIVITY DIAGRAMS & FLOWCHARTS
================================================================================

ACTIVITY: COMPLETE USER REGISTRATION PROCESS
═════════════════════════════════════════════

                              ┌─────────┐
                              │ START   │
                              └────┬────┘
                                   │
                    ┌──────────────┴──────────────┐
                    │                            │
                    ▼                            │
            ┌──────────────────┐               │
            │ User Clicks      │               │
            │ "Sign Up"        │               │
            └────────┬─────────┘               │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ Display Signup Form      │       │
            │ (name, email, password)  │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Enters Form Data    │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Clicks "Sign Up"    │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ◇──────────────────────────◇       │
            │ Validate Email Domain    │       │
            │ (must be @bazeuniversity)        │
            ◇────────┬───────────────◇         │
                  NO │                         │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ Show Error:              │       │
            │ "Email must be @baze..." │       │
            └────────┬─────────────────┘───┐   │
                     │                     │   │
                     │  Go back to form    │   │
                     └─────────────────────┘   │
                                               │
            [Back in form]                     │
            ┌──────────────────────────┐       │
            │ YES - Domain Valid       │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ◇──────────────────────────◇       │
            │ Validate Password        │       │
            │ (6+ chars, 1 upper,      │       │
            │  1 number)               │       │
            ◇────────┬───────────────◇         │
                  NO │                         │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ Show Error:              │       │
            │ "Password must have..."  │       │
            └────────┬─────────────────┘───────┘
                     │
                     │ Go back to form
                     │
            [Correct Password]
            ┌──────────────────────────┐
            │ YES - Password Valid     │
            └────────┬─────────────────┘
                     │
                     ▼
            ◇──────────────────────────◇
            │ Check Username/Email    │
            │ Uniqueness in Database  │
            ◇────────┬───────────────◇
                  NO │
                     │
                     ▼
            ┌──────────────────────────┐
            │ Show Error:              │
            │ "Email/Username taken"   │
            └────────┬─────────────────┘───┐
                     │                     │
                     │  Go back to form    │
                     └─────────────────────┘

            [Unique Username/Email]
            ┌──────────────────────────┐
            │ YES - Unique OK          │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Hash Password with       │
            │ bcrypt                   │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Create User Record in    │
            │ Database                 │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Generate JWT Token       │
            │ (expires 7 days)         │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Return Token + User Data │
            │ to Frontend              │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Show Success Checkmark   │
            │ (Green)                  │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Store Token in           │
            │ localStorage             │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Auto-Login (Trigger      │
            │ POST /login)             │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Redirect to Profile Page │
            └────────┬─────────────────┘
                     │
                     ▼
                  ◇─────◇
                  │ END │
                  ◇─────◇


ACTIVITY: CREATE PRODUCT LISTING
═════════════════════════════════

                              ┌─────────┐
                              │ START   │
                              └────┬────┘
                                   │
                    ┌──────────────┴──────────────┐
                    │                            │
                    ▼                            │
            ┌──────────────────┐               │
            │ User Clicks      │               │
            │ "New Listing"    │               │
            └────────┬─────────┘               │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ Display Product Form     │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Selects Product     │       │
            │ Category                 │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Enters:             │       │
            │ - Name                   │       │
            │ - Description            │       │
            │ - Price                  │       │
            │ - Condition              │       │
            │ - Size (optional)        │       │
            │ - Color (optional)       │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Clicks Image        │       │
            │ Upload Area              │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ File Picker Opens        │       │
            │ (Image files only)       │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ User Selects 3-5 Images │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ┌──────────────────────────┐       │
            │ System Shows Preview     │       │
            │ for Each Image           │       │
            └────────┬─────────────────┘       │
                     │                         │
                     ▼                         │
            ◇──────────────────────────◇       │
            │ Count Images             │       │
            │ (must be 3-5)            │       │
            ◇───────┬─────────────◇           │
                   │                         │
         ┌─────────┴─────────┐              │
         │                   │              │
    <3 Images           >5 Images            │
         │                   │              │
         ▼                   ▼              │
    Red X Error       Red X Error           │
    "Need 3+"         "Max 5 only"          │
         │                   │              │
         └─────────┬─────────┘              │
                   │                        │
            Go back to select more/fewer    │
            images                          │
                   │                        │
    [Exactly 3-5 images]                   │
            ┌──────────────────────────┐   │
            │ Green Checkmark          │   │
            │ "Ready to sell!"         │   │
            └────────┬─────────────────┘   │
                     │                     │
                     ▼                     │
            ┌──────────────────────────┐   │
            │ User Clicks "Create"     │   │
            └────────┬─────────────────┘   │
                     │                     │
                     ▼                     │
            ┌──────────────────────────┐   │
            │ Show Loading Spinner     │   │
            │ "Uploading images..."    │   │
            └────────┬─────────────────┘   │
                     │                     │
            [Upload each image]             │
            ┌──────────────────────────┐   │
            │ For each of 3-5 images: │   │
            │ POST /api/upload         │   │
            └────────┬─────────────────┘   │
                     │                     │
            [All images uploaded]           │
            ┌──────────────────────────┐   │
            │ POST /api/products       │   │
            │ (with all image URLs)    │   │
            └────────┬─────────────────┘   │
                     │                     │
            ◇──────────────────────────◇   │
            │ Validate Product Data    │   │
            ◇────────┬───────────────◇     │
                  NO │                     │
                     │                     │
                     ▼                     │
            ┌──────────────────────────┐   │
            │ Show Error Message       │   │
            └────────┬─────────────────┼───┘
                     │                 │
                     │  Go back to form│
                     └─────────────────┘

            [Validation OK]
            ┌──────────────────────────┐
            │ YES - Data Valid         │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Create Product Record    │
            │ in Database              │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Create 3-5 Image Records │
            │ in Database              │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Show Success Checkmark   │
            │ (Green)                  │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Redirect to Profile      │
            │ "My Listings" Tab        │
            └────────┬─────────────────┘
                     │
                     ▼
            ┌──────────────────────────┐
            │ Show New Product in      │
            │ Marketplace (Products    │
            │ Page)                    │
            └────────┬─────────────────┘
                     │
                     ▼
                  ◇─────◇
                  │ END │
                  ◇─────◇


================================================================================
11.6 CLASS DIAGRAM (DATABASE OBJECT RELATIONSHIPS)
================================================================================

Shows how Java/Python classes relate to database tables:

┌─────────────────────────────────────────────────────────────────────┐
│                    UNIMARKET CLASS STRUCTURE                        │
└─────────────────────────────────────────────────────────────────────┘

┌──────────────────────┐
│   University         │
├──────────────────────┤
│ - id: Integer (PK)   │
│ - name: String       │
│ - domain: String     │
│                      │
│ Methods:             │
│ + getUsers()         │
│ + addUser(User)      │
└────────┬─────────────┘
         │
         │ ONE-to-MANY
         │ (1 university has many users)
         │
         ▼
┌────────────────────────────────────┐
│   User                             │
├────────────────────────────────────┤
│ - id: Integer (PK)                 │
│ - fullName: String                 │
│ - username: String (UNIQUE)        │
│ - email: String (UNIQUE)           │
│ - passwordHash: String             │
│ - bio: String (nullable)           │
│ - profileImage: String (nullable)  │
│ - phone: String (nullable)         │
│ - createdAt: DateTime              │
│ - universityId: Integer (FK)       │
│                                    │
│ Relationships:                     │
│ - university: University (FK)      │
│ - products: List<Product>          │
│ - savedItems: List<SavedItem>      │
│                                    │
│ Methods:                           │
│ + register(name, email, pass)      │
│ + login(email, pass): JWT Token    │
│ + updateProfile(data)              │
│ + uploadAvatar(image)              │
│ + getProfile(): UserData           │
│ + getListings(): List<Product>     │
│ + getSavedItems(): List<Product>   │
└──┬───────────────────────────────┬─┘
   │                               │
   │ ONE-to-MANY                   │ ONE-to-MANY
   │ (seller)                       │ (saver)
   │                               │
   ▼                               ▼
┌──────────────────────┐      ┌──────────────────────┐
│   Product            │      │   SavedItem          │
├──────────────────────┤      ├──────────────────────┤
│ - id: Integer (PK)   │      │ - id: Integer (PK)   │
│ - name: String       │      │ - userId: Int (FK)   │
│ - description: Text  │      │ - productId: Int(FK) │
│ - price: Float       │      │ - createdAt: DateTime│
│ - categoryId: Int(FK)│      │                      │
│ - sellerId: Int (FK) │      │ Relationships:       │
│ - location: String   │      │ - user: User (FK)    │
│ - condition: String  │      │ - product: Product   │
│ - size: String       │      │   (FK)               │
│ - color: String      │      │                      │
│ - status: String     │      │ Methods:             │
│ - createdAt: DateTime│      │ + save()             │
│ - updatedAt: DateTime│      │ + remove()           │
│                      │      │ + isSavedBy(): bool  │
│ Relationships:       │      └──────────────────────┘
│ - category: Category │
│   (FK)               │
│ - seller: User (FK)  │
│ - images: List<PI>   │
│ - savedBy: List<SI>  │
│                      │
│ Methods:             │
│ + create(data)       │
│ + update(data)       │
│ + delete() [soft]    │
│ + getDetails()       │
│ + getImages()        │
│ + getSellers()       │
│ + search(query)      │
│ + filter(criteria)   │
└──┬───────────────────┘
   │
   │ ONE-to-MANY
   │ (product has many images)
   │
   ▼
┌──────────────────────┐
│  ProductImage        │
├──────────────────────┤
│ - id: Integer (PK)   │
│ - productId: Int(FK) │
│ - imageUrl: String   │
│ - isPrimary: Boolean │
│ - createdAt: DateTime│
│                      │
│ Relationships:       │
│ - product: Product   │
│   (FK)               │
│                      │
│ Methods:             │
│ + upload(file)       │
│ + delete()           │
│ + getUrl(): String   │
└──────────────────────┘

         ▲
         │
    ONE-to-MANY
    (product belongs to category)
         │
┌────────┴──────────────┐
│   Category             │
├───────────────────────┤
│ - id: Integer (PK)    │
│ - name: String        │
│   (UNIQUE)            │
│                       │
│ Relationships:        │
│ - products:           │
│   List<Product>       │
│                       │
│ Methods:              │
│ + getProducts()       │
│ + addProduct()        │
└───────────────────────┘


================================================================================
CONCLUSION
================================================================================

UniMarket successfully implements a complete peer-to-peer campus marketplace
with robust security, comprehensive features, and scalable architecture.

KEY ACHIEVEMENTS:
- Secure authentication (bcrypt + JWT)
- University-gated access (email domain validation)
- Complete product management system
- User profile system with access control
- Image upload with multiple file support
- Search and filtering capabilities
- Responsive design for all devices
- Well-documented, maintainable codebase
- Database-agnostic architecture (SQLite → PostgreSQL)

READY FOR PRODUCTION DEPLOYMENT
With some security enhancements:
- Configure environment variables (JWT_SECRET_KEY)
- Enable HTTPS
- Use PostgreSQL instead of SQLite
- Add email verification
- Implement rate limiting
- Add audit logging
- Set up automated backups

================================================================================
